{"version":3,"sources":["webpack:///augmented2.js","webpack:///webpack/bootstrap 2ca07af6c394fd6cf234","webpack:///./src/isString.js","webpack:///./src/logger.js","webpack:///./src/map.js","webpack:///./src/object.js","webpack:///./src/stack.js","webpack:///./src/utility.js","webpack:///./src/augmented.js","webpack:///./~/lodash.bind/index.js","webpack:///(webpack)/buildin/global.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_typeof","Symbol","iterator","obj","constructor","isString","val","toString","default","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","TypeError","create","writable","setPrototypeOf","__proto__","_classCallCheck","instance","Constructor","_createClass","defineProperties","target","props","length","descriptor","key","protoProps","staticProps","pad","str","padLeft","slice","substring","Type","CONSOLE","COLOR_CONSOLE","REST","Level","INFO","DEBUG","ERROR","WARN","AbstractLogger","this","TIME_SEPERATOR","DATE_SEPERATOR","OPEN_GROUP","CLOSE_GROUP","label","loggerLevel","now","Date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","message","level","_logMe","_getLogTime","log","ConsoleLogger","_AbstractLogger","getPrototypeOf","console","info","error","warn","ColorConsoleLogger","_AbstractLogger2","RestLogger","_AbstractLogger3","uri","_this3","LoggerFactory","type","_isString","_isString2","AugmentedMap","myData","_keys","_data","marshall","push","indexOf","splice","fn","len","k","entries","Array","values","JSON","stringify","dataToMarshall","dataToParse","toJSON","keys","parse","e","v","set","_arguments","arguments","_bind","idCounter","_uniqueId","prefix","_before","nn","func","result","FUNC_ERROR_TEXT","Number","parseInt","apply","undefined","_once","EVENT_SPLITTER","eventsApi","iteratee","events","callback","opts","names","context","test","split","internalOn","listening","_events","onApi","ctx","_listeners","id","options","handlers","count","offApi","listeners","remaining","j","handler","_callback","listeningTo","objId","ids","triggerApi","objEvents","args","allEvents","all","triggerEvents","concat","ev","a1","a2","a3","AugmentedObject","_options","_listeningTo","_listenId","assign","Math","max","argsA","_onceMap","off","on","thisId","stopListening","listenTo","map","offer","_this","_arguments2","__once","Stack","_stack","pop","item","TransformerType","shuffle","array","nArray","temp","floor","random","prettyPrint","spaces","number","x","repeat","sortObjects","sort","a","b","y","binarySearch","arr","find","comparator","low","high","comparison","quickSort","left","right","pivot","STRING","INTEGER","NUMBER","BOOLEAN","ARRAY","OBJECT","NULL","Transformer","source","out","String","Boolean","isArray","wrap","filterObject","newObject","extend","_len","_key","_interopRequireDefault","_interopRequireWildcard","newObj","_utility","Utility","_logger","Logger","_object","_object2","_map","_map2","_stack2","Augmented","Map","VERSION","codename","releasename","_","$","Configuration","LoggerLevel","MessageBundle","AsynchronousQueueTimeout","ApplicationInitProcessTimeout","has","isObject","allKeys","getOwnPropertyNames","methodMap","update","patch","delete","read","sync","method","model","params","dataType","url","Error","isFunction","data","contentType","attrs","processData","xhr","textStatus","errorThrown","ajax","trigger","arrayHas","exec","functionName","namespaces","isDefined","global","thisArg","arrayEach","index","arrayIncludes","baseIndexOf","baseFindIndex","predicate","fromIndex","fromRight","baseIsNaN","countHolders","placeholder","getValue","isHostObject","replaceHolders","resIndex","PLACEHOLDER","baseCreate","proto","objectCreate","baseIsNative","isMasked","reIsNative","reIsHostCtor","toSource","composeArgs","partials","holders","isCurried","argsIndex","argsLength","holdersLength","leftIndex","leftLength","rangeLength","nativeMax","isUncurried","composeArgsRight","holdersIndex","rightIndex","rightLength","offset","copyArray","createBind","bitmask","wrapper","root","Ctor","isBind","BIND_FLAG","createCtor","thisBinding","createCurry","arity","getHolder","createRecurry","createHybrid","partialsRight","holdersRight","argPos","ary","holdersCount","newHolders","isBindKey","reorder","isFlip","reverse","isAry","ARY_FLAG","BIND_KEY_FLAG","CURRY_FLAG","CURRY_RIGHT_FLAG","FLIP_FLAG","createPartial","wrapFunc","isCurry","newHoldersRight","newPartials","newPartialsRight","PARTIAL_FLAG","PARTIAL_RIGHT_FLAG","CURRY_BOUND_FLAG","setWrapToString","createWrap","toInteger","newData","getNative","getWrapDetails","match","reWrapDetails","reSplitDetails","insertWrapDetails","details","lastIndex","join","replace","reWrapComment","isIndex","MAX_SAFE_INTEGER","reIsUint","maskSrcKey","indexes","arrLength","nativeMin","oldArray","funcToString","updateWrapDetails","wrapFlags","pair","tag","objectToString","funcTag","genTag","isObjectLike","isSymbol","symbolTag","toFinite","toNumber","INFINITY","MAX_INTEGER","remainder","NAN","other","valueOf","reTrim","isBinary","reIsBinary","reIsOctal","freeParseInt","reIsBadHex","constant","identity","reRegExpChar","freeGlobal","freeSelf","Function","funcProto","objectProto","coreJsData","uid","IE_PROTO","RegExp","min","reference","bind","start","otherArgs","g","eval","window"],"mappings":"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","file":"augmented2.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Augmented.isString -\n * checks if a value is a String\n * @method isString\n * @memberof Augmented\n * @param {string} variable to check\n * @returns {boolean} true if value is a string\n */\nvar isString = function isString(val) {\n  return typeof val === \"string\" || !!val && (typeof val === \"undefined\" ? \"undefined\" : _typeof(val)) === \"object\" && Object.prototype.toString.call(val) === \"[object String]\";\n};\n\nexports.default = isString;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A Logger package\n * @namespace Augmented.Logger\n * @memberof Augmented\n */\n\nvar pad = function pad(p, str, padLeft) {\n  if (typeof str === \"undefined\") {\n    return p;\n  }\n  if (padLeft) {\n    return (p + str).slice(-p.length);\n  } else {\n    return (p + pad).substring(0, p.length);\n  }\n};\n\n/**\n * Augmented.Logger.Type\n * @name Augmented.Logger.Type\n * @enum {Symbol}\n * @memberof Augmented.Logger\n * @property {Symbol} CONSOLE The console logger (HTML5 console)\n * @property {Symbol} COLOR_CONSOLE The color console logger (HTML5 console)\n * @property {Symbol} REST A REST-based logger\n * @memberof Augmented.Logger\n */\nvar Type = exports.Type = {};\nType.CONSOLE = Symbol(\"console\");\nType.COLOR_CONSOLE = Symbol(\"colorConsole\");\nType.REST = Symbol(\"rest\");\n\n/**\n * Augmented.Logger.Level\n * @name Augmented.Logger.Level\n * @enum {Symbol}\n * @property {Symbol} INFO The Info level\n * @property {Symbol} DEBUG The debug level\n * @property {Symbol} ERROR The error level\n * @property {Symbol} WARN The warning level\n * @memberof Augmented.Logger\n */\nvar Level = exports.Level = {};\nLevel.INFO = Symbol(\"info\");\nLevel.DEBUG = Symbol(\"debug\");\nLevel.ERROR = Symbol(\"error\");\nLevel.WARN = Symbol(\"warn\");\n\n/**\n * Augmented Abstract Logger\n * @constructor Augmented.AbstractLogger\n * @param {Augmented.Logger.Level} l The level to initialize the logger with\n * @abstract\n * @memberof Augmented\n */\n\nvar AbstractLogger = function () {\n  function AbstractLogger(l) {\n    _classCallCheck(this, AbstractLogger);\n\n    this.TIME_SEPERATOR = \":\";\n    this.DATE_SEPERATOR = \"-\";\n    this.OPEN_GROUP = \" [ \";\n    this.CLOSE_GROUP = \" ] \";\n    this.label = Level;\n\n    this.loggerLevel = l ? l : Level.INFO;\n  }\n\n  _createClass(AbstractLogger, [{\n    key: \"_getLogTime\",\n    value: function _getLogTime() {\n      var now = new Date();\n      var s = \"\" + now.getFullYear() + this.DATE_SEPERATOR + (now.getMonth() + 1) + this.DATE_SEPERATOR + now.getDate() + \" \" + now.getHours() + this.TIME_SEPERATOR + now.getMinutes() + this.TIME_SEPERATOR + now.getSeconds() + this.TIME_SEPERATOR + now.getMilliseconds();\n      return pad(\"                        \", s, false);\n    }\n  }, {\n    key: \"log\",\n\n\n    /**\n     * log a message\n     * @method log\n     * @memberof AbstractLogger\n     * @param {string} message The message to log\n     * @param {Augmented.Logger.Level} level The level of the log message\n     * @returns {string} The message\n     */\n    value: function log(message, level) {\n      var m = \"\";\n      if (message) {\n        if (!level) {\n          level = Level.INFO;\n        }\n        if (this.loggerLevel === Level.DEBUG && level === Level.DEBUG) {\n          m = this._logMe(\"\" + this._getLogTime() + this.OPEN_GROUP + \"DEBUG\" + this.CLOSE_GROUP + message, level);\n        } else if (level === Level.ERROR) {\n          m = this._logMe(\"\" + this._getLogTime() + this.OPEN_GROUP + \"ERROR\" + this.CLOSE_GROUP + message, level);\n        } else if (level === Level.WARN) {\n          m = this._logMe(\"\" + this._getLogTime() + this.OPEN_GROUP + \"WARN \" + this.CLOSE_GROUP + message, level);\n        } else if (this.loggerLevel === Level.DEBUG || this.loggerLevel === Level.INFO) {\n          m = this._logMe(\"\" + this._getLogTime() + this.OPEN_GROUP + \"INFO \" + this.CLOSE_GROUP + message, level);\n        }\n      }\n      return m;\n    }\n  }, {\n    key: \"info\",\n\n\n    /**\n     * Logs a message in info level\n     * @method info\n     * @param {string} message\n     * @memberof AbstractLogger\n     */\n    value: function info(message) {\n      this.log(message, Level.INFO);\n    }\n  }, {\n    key: \"error\",\n\n\n    /**\n     * Log a message in error level\n     * @method error\n     * @param {string} message\n     * @memberof AbstractLogger\n     */\n    value: function error(message) {\n      this.log(message, Level.ERROR);\n    }\n  }, {\n    key: \"debug\",\n\n\n    /**\n     * Log a message in debug level\n     * @method debug\n     * @param {string} message\n     * @memberof AbstractLogger\n     */\n    value: function debug(message) {\n      this.log(message, Level.DEBUG);\n    }\n  }, {\n    key: \"warn\",\n\n\n    /**\n     * Log a message in warn level\n     * @method warn\n     * @param {string} message\n     * @memberof AbstractLogger\n     */\n    value: function warn(message) {\n      this.log(message, Level.WARN);\n    }\n  }, {\n    key: \"_logMe\",\n\n\n    /**\n     * logMe method - the actual logger method that logs.  Each instance will have it's own<br/>\n     * override this in an instance\n     * @example _logMe(message, level) { ... };\n     * @method _logMe\n     * @param {string} message The message to log\n     * @param {string} level The level to log to\n     * @returns {string} The message\n     * @memberof AbstractLogger\n     * @private\n     */\n    value: function _logMe(message, level) {}\n  }]);\n\n  return AbstractLogger;\n}();\n\n;\n\nvar ConsoleLogger = function (_AbstractLogger) {\n  _inherits(ConsoleLogger, _AbstractLogger);\n\n  function ConsoleLogger(l) {\n    _classCallCheck(this, ConsoleLogger);\n\n    return _possibleConstructorReturn(this, (ConsoleLogger.__proto__ || Object.getPrototypeOf(ConsoleLogger)).call(this, l));\n  }\n\n  _createClass(ConsoleLogger, [{\n    key: \"_logMe\",\n    value: function _logMe(message, level) {\n      if (level === Level.INFO) {\n        console.info(message);\n      } else if (level === Level.ERROR) {\n        console.error(message);\n      } else if (level === Level.DEBUG) {\n        console.log(message);\n      } else if (level === Level.WARN) {\n        console.warn(message);\n      } else {\n        console.log(message);\n      }\n      return message;\n    }\n  }]);\n\n  return ConsoleLogger;\n}(AbstractLogger);\n\n;\n\nvar ColorConsoleLogger = function (_AbstractLogger2) {\n  _inherits(ColorConsoleLogger, _AbstractLogger2);\n\n  function ColorConsoleLogger(l) {\n    _classCallCheck(this, ColorConsoleLogger);\n\n    return _possibleConstructorReturn(this, (ColorConsoleLogger.__proto__ || Object.getPrototypeOf(ColorConsoleLogger)).call(this, l));\n  }\n\n  _createClass(ColorConsoleLogger, [{\n    key: \"_logMe\",\n    value: function _logMe(message, level) {\n      if (level === Level.INFO) {\n        console.info(\"\\x1b[36m\" + message + \"\\x1b[0m\");\n      } else if (level === Level.ERROR) {\n        console.error(\"\\x1b[31m\" + message + \"\\x1b[0m\");\n      } else if (level === Level.DEBUG) {\n        console.log(\"\\x1b[34m\" + message + \"\\x1b[0m\");\n      } else if (level === Level.WARN) {\n        console.warn(\"\\x1b[33m\" + message + \"\\x1b[0m\");\n      } else {\n        console.log(\"\\x1b[37m\" + message + \"\\x1b[0m\");\n      }\n    }\n  }]);\n\n  return ColorConsoleLogger;\n}(AbstractLogger);\n\n;\n\nvar RestLogger = function (_AbstractLogger3) {\n  _inherits(RestLogger, _AbstractLogger3);\n\n  function RestLogger(l, uri) {\n    _classCallCheck(this, RestLogger);\n\n    var _this3 = _possibleConstructorReturn(this, (RestLogger.__proto__ || Object.getPrototypeOf(RestLogger)).call(this, l));\n\n    _this3.uri = uri;\n    return _this3;\n  }\n\n  _createClass(RestLogger, [{\n    key: \"setURI\",\n    value: function setURI(uri) {\n      this.uri = uri;\n    }\n  }, {\n    key: \"_logMe\",\n    value: function _logMe(message) {\n      // use new ajax promise\n      /*\n      Augmented.ajax({\n        url: this.uri,\n        method: \"POST\",\n        contentType: \"text/plain\",\n        dataType: \"text\",\n        async: true,\n        data: message,\n        success: function (data, status) { this.success(); },\n        failure: function (data, status) { this.failure(); }\n      });\n      */\n    }\n  }]);\n\n  return RestLogger;\n}(AbstractLogger);\n\n;\n\n/**\n* Augmented.Logger.LoggerFactory - A logger factory for creating a logger instance\n* @namespace Augmented.Logger.LoggerFactory\n* @memberof Augmented.Logger\n*/\n\nvar LoggerFactory = exports.LoggerFactory = function () {\n  function LoggerFactory() {\n    _classCallCheck(this, LoggerFactory);\n  }\n\n  _createClass(LoggerFactory, null, [{\n    key: \"getLogger\",\n\n    /**\n     * getLogger - get an instance of a logger\n     * @method getLogger\n     * @param {Augmented.Logger.Type} type Type of logger instance\n     * @param {Augmented.Logger.Level} level Level to set the logger to\n     * @memberof Augmented.Logger.LoggerFactory\n     * @returns {Augmented.Logger.abstractLogger} logger Instance of a logger by istance type\n     * @example Augmented.Logger.LoggerFactory.getLogger(Augmented.Logger.Type.console, Augmented.Logger.Level.debug);\n     */\n    value: function getLogger(type, level) {\n      if (type === Type.CONSOLE) {\n        return new ConsoleLogger(level);\n      } else if (type === Type.COLOR_CONSOLE) {\n        return new ColorConsoleLogger(level);\n      } else if (type === Type.REST) {\n        return new RestLogger(level);\n      }\n    }\n  }]);\n\n  return LoggerFactory;\n}();\n\n;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _isString = __webpack_require__(0);\n\nvar _isString2 = _interopRequireDefault(_isString);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * ES6-like Map - than can marshall\n * @constructor Augmented.Utility.Map\n * @param myData {object} Map data to fill map\n * @memberof Augmented.Utility\n */\nvar AugmentedMap = function () {\n  function AugmentedMap(myData) {\n    _classCallCheck(this, AugmentedMap);\n\n    this._keys = [];\n    this._data = {};\n\n    if (myData) {\n      this.marshall(myData);\n    }\n  }\n\n  _createClass(AugmentedMap, [{\n    key: \"set\",\n\n\n    /**\n     * Set the value by key in the map\n     * @method set\n     * @memberof Augmented.Utility.Map\n     * @param {string} key name of the key\n     * @param {any} value value for the key\n     */\n    value: function set(key, value) {\n      if (key !== null && value !== null) {\n        if (!this._data[key]) {\n          this._keys.push(key);\n        }\n        this._data[key] = value;\n      }\n    }\n  }, {\n    key: \"get\",\n\n\n    /**\n     * Get the value by key in the map\n     * @method get\n     * @memberof Augmented.Utility.Map\n     * @param {string} key name of the key\n     * @returns {any} The value for the key\n     */\n    value: function get(key) {\n      return this._data[key];\n    }\n  }, {\n    key: \"indexOf\",\n\n\n    /**\n     * Index of the key in the map\n     * @method indexOf\n     * @memberof Augmented.Utility.Map\n     * @param {string} key name of the key\n     * @returns {number} index of the key\n     */\n    value: function indexOf(key) {\n      return this._keys.indexOf(key);\n    }\n  }, {\n    key: \"remove\",\n\n\n    /**\n     * Remove the value by key in the map\n     * @method remove\n     * @memberof Augmented.Utility.Map\n     * @param {string} key name of the key\n     */\n    value: function remove(key) {\n      var i = this.indexOf(key);\n      this._keys.splice(i, 1);\n      delete this._data[key];\n    }\n  }, {\n    key: \"has\",\n\n\n    /**\n     * Has returns whether a key exists in the map\n     * @method has\n     * @memberof Augmented.Utility.Map\n     * @param {string} key name of the key\n     * @returns {boolean} true if the key exists in the map\n     */\n    value: function has(key) {\n      return this.indexOf(key) !== -1;\n    }\n  }, {\n    key: \"forEach\",\n\n\n    /**\n     * Iterator forEach key to value in the map\n     * @method forEach\n     * @memberof Augmented.Utility.Map\n     * @param {function} fn callback for the iterator\n     */\n    value: function forEach(fn) {\n      if (typeof fn !== \"function\") {\n        return null;\n      }\n      var len = this._keys.length;\n      var i = 0,\n          k = void 0;\n      for (i = 0; i < len; i++) {\n        k = this._keys[i];\n        fn(k, this._data[k], i);\n      }\n    }\n  }, {\n    key: \"key\",\n\n\n    /**\n     * Get the key for the index in the map\n     * @method key\n     * @memberof Augmented.Utility.Map\n     * @param {number} i index of the key\n     * @returns {object} the key at index\n     */\n    value: function key(i) {\n      return this._keys[i];\n    }\n  }, {\n    key: \"entries\",\n\n\n    /**\n     * The entries value object in the map\n     * @method entries\n     * @memberof Augmented.Utility.Map\n     * @returns {array} Array of entries value objects\n     */\n    value: function entries() {\n      var i = 0;\n      var len = this._keys.length,\n          entries = new Array(len);\n      for (i = 0; i < len; i++) {\n        entries[i] = {\n          key: this._keys[i],\n          value: this._data[i]\n        };\n      }\n      return entries;\n    }\n  }, {\n    key: \"values\",\n\n\n    /**\n     * The values in the map as an Array\n     * @method values\n     * @memberof Augmented.Utility.Map\n     * @returns {array} values as an Array\n     */\n    value: function values() {\n      var len = this._keys.length,\n          values = new Array(len);\n      var i = 0,\n          key = void 0;\n\n      for (i = 0; i < len; i++) {\n        key = this._keys[i];\n        values[i] = this._data[key];\n      }\n      return values;\n    }\n  }, {\n    key: \"clear\",\n\n\n    /**\n     * Clear the map\n     * @method clear\n     * @memberof Augmented.Utility.Map\n     */\n    value: function clear() {\n      this._keys = [];\n      this._data = {};\n    }\n  }, {\n    key: \"size\",\n\n\n    /**\n     * The size of the map in keys\n     * @method size\n     * @memberof Augmented.Utility.Map\n     * @returns {number} size of map by keys\n     */\n    value: function size() {\n      return this._keys.length;\n    }\n  }, {\n    key: \"toJSON\",\n\n\n    /**\n     * Represent the map in JSON\n     * @method toJSON\n     * @memberof Augmented.Utility.Map\n     * @returns {object} JSON of the map\n     */\n    value: function toJSON() {\n      return this._data;\n    }\n  }, {\n    key: \"toString\",\n\n\n    /**\n     * Represent the map in a String of JSON\n     * @method toString\n     * @memberof Augmented.Utility.Map\n     * @returns {string} Stringified JSON of the map\n     */\n    value: function toString() {\n      return JSON.stringify(this._data);\n    }\n  }, {\n    key: \"isEmpty\",\n\n\n    // non-es6 API\n\n    /**\n     * Checks of the map is empty (not ES6)\n     * @method isEmpty\n     * @memberof Augmented.Utility.Map\n     * @returns {boolean} true if the map is empty\n     */\n    value: function isEmpty() {\n      return this._keys.length === 0;\n    }\n  }, {\n    key: \"marshall\",\n\n\n    /**\n     * Marshalls a map<br/>\n     * dataToMarshall must be the following type of data to parse:\n     * JSON object with properties (key/value)\n     *\n     * @method marshall\n     * @param {Augmented.Utility.Map} dataToMarshall Data to marshall as a map\n     * @returns {boolean} Returns true on success\n     * @memberof Augmented.Utility.Map\n     */\n    value: function marshall(dataToMarshall) {\n      var dataToParse = void 0;\n      if (dataToMarshall && dataToMarshall instanceof AugmentedMap) {\n        dataToParse = dataToMarshall.toJSON();\n      } else if (dataToMarshall && dataToMarshall instanceof Object && Object.keys(dataToMarshall).length > 0) {\n        dataToParse = dataToMarshall;\n      } else if (dataToMarshall && (0, _isString2.default)(dataToMarshall)) {\n        try {\n          dataToParse = JSON.parse(dataToMarshall);\n        } catch (e) {\n          //_logger.warn(\"AUGMENTED: Map: Could not marshall data: \" + JSON.stringify(dataToMarshall));\n          return false;\n        }\n      } else {\n        //_logger.warn(\"AUGMENTED: Map: Could not marshall data: \" + JSON.stringify(dataToMarshall));\n        return false;\n      }\n\n      var props = Object.keys(dataToParse),\n          l = props.length;\n      var i = 0;\n      for (i = 0; i < l; i++) {\n        var p = props[i],\n            v = dataToParse[p];\n        this.set(p, v);\n      }\n      return true;\n    }\n  }]);\n\n  return AugmentedMap;\n}();\n\n;\n\nexports.default = AugmentedMap;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _arguments = arguments;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _bind = __webpack_require__(7);\n\nvar idCounter = 0;\n\n// some lodash-like functions ported over\nvar _keys = function _keys(object) {\n  return Object.keys(object);\n};\nvar _uniqueId = function _uniqueId(prefix) {\n  var id = ++idCounter;\n  return \"{$prefix}\" + id;\n};\nvar _before = function _before(nn, func) {\n  var result = void 0,\n      n = void 0;\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  n = Number.parseInt(nn);\n  return function () {\n    if (--n > 0) {\n      result = func.apply(undefined, _arguments);\n    }\n    if (n <= 1) {\n      func = undefined;\n    }\n    return result;\n  };\n};\nvar _once = function _once(func) {\n  return _before(2, func);\n};\n\n// Events\n\n// Regular expression used to split event strings.\nvar EVENT_SPLITTER = /\\s+/;\n\n// Iterates over the standard `event, callback` (as well as the fancy multiple\n// space-separated events `\"change blur\", callback` and jQuery-style event\n// maps `{event: callback}`).\nvar eventsApi = function eventsApi(iteratee, events, name, callback, opts) {\n  var i = 0,\n      names = void 0;\n  if (name && (typeof name === \"undefined\" ? \"undefined\" : _typeof(name)) === \"object\") {\n    // Handle event maps.\n    if (callback !== void 0 && \"context\" in opts && opts.context === void 0) {\n      opts.context = callback;\n    }\n    for (names = _keys(name); i < names.length; i++) {\n      events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\n    }\n  } else if (name && EVENT_SPLITTER.test(name)) {\n    // Handle space-separated event names by delegating them individually.\n    for (names = name.split(EVENT_SPLITTER); i < names.length; i++) {\n      events = iteratee(events, names[i], callback, opts);\n    }\n  } else {\n    // Finally, standard events.\n    events = iteratee(events, name, callback, opts);\n  }\n  return events;\n};\n\n// Guard the `listening` argument from the public API.\nvar internalOn = function internalOn(obj, name, callback, context, listening) {\n  obj._events = eventsApi(onApi, obj._events || {}, name, callback, {\n    context: context,\n    ctx: obj,\n    listening: listening\n  });\n\n  if (listening) {\n    var listeners = obj._listeners || (obj._listeners = {});\n    listeners[listening.id] = listening;\n  }\n  return obj;\n};\n\n// The reducing API that adds a callback to the `events` object.\nvar onApi = function onApi(events, name, callback, options) {\n  if (callback) {\n    var handlers = events[name] || (events[name] = []);\n    var context = options.context,\n        ctx = options.ctx,\n        listening = options.listening;\n    if (listening) {\n      listening.count++;\n    }\n    handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });\n  }\n  return events;\n};\n\n// The reducing API that removes a callback from the `events` object.\nvar offApi = function offApi(events, name, callback, options) {\n  if (!events) {\n    return;\n  }\n  var i = 0,\n      listening = void 0;\n  var context = options.context,\n      listeners = options.listeners;\n\n  // Delete all events listeners and \"drop\" events.\n  if (!name && !callback && !context) {\n    var ids = _keys(listeners);\n    for (; i < ids.length; i++) {\n      listening = listeners[ids[i]];\n      delete listeners[listening.id];\n      delete listening.listeningTo[listening.objId];\n    }\n    return;\n  }\n\n  var names = name ? [name] : _keys(events);\n  for (; i < names.length; i++) {\n    name = names[i];\n    var handlers = events[name];\n\n    // Bail out if there are no events stored.\n    if (!handlers) break;\n\n    // Replace events if there are any remaining.  Otherwise, clean up.\n    var remaining = [];\n    var j = 0;\n    for (j = 0; j < handlers.length; j++) {\n      var handler = handlers[j];\n      if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {\n        remaining.push(handler);\n      } else {\n        listening = handler.listening;\n        if (listening && --listening.count === 0) {\n          delete listeners[listening.id];\n          delete listening.listeningTo[listening.objId];\n        }\n      }\n    }\n\n    // Update tail event if the list has any events.  Otherwise, clean up.\n    if (remaining.length) {\n      events[name] = remaining;\n    } else {\n      delete events[name];\n    }\n  }\n  return events;\n};\n\n// Handles triggering the appropriate event callbacks.\nvar triggerApi = function triggerApi(objEvents, name, callback, args) {\n  if (objEvents) {\n    var events = objEvents[name];\n    var allEvents = objEvents.all;\n    if (events && allEvents) {\n      allEvents = allEvents.slice();\n    }\n    if (events) {\n      triggerEvents(events, args);\n    }\n    if (allEvents) {\n      triggerEvents(allEvents, [name].concat(args));\n    }\n  }\n  return objEvents;\n};\n\n// A difficult-to-believe, but optimized internal dispatch function for\n// triggering events. Tries to keep the usual cases speedy\nvar triggerEvents = function triggerEvents(events, args) {\n  var ev = void 0,\n      i = -1;\n  var l = events.length,\n      a1 = args[0],\n      a2 = args[1],\n      a3 = args[2];\n  switch (args.length) {\n    case 0:\n      while (++i < l) {\n        (ev = events[i]).callback.call(ev.ctx);\n      }return;\n    case 1:\n      while (++i < l) {\n        (ev = events[i]).callback.call(ev.ctx, a1);\n      }return;\n    case 2:\n      while (++i < l) {\n        (ev = events[i]).callback.call(ev.ctx, a1, a2);\n      }return;\n    case 3:\n      while (++i < l) {\n        (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n      }return;\n    default:\n      while (++i < l) {\n        (ev = events[i]).callback.apply(ev.ctx, args);\n      }return;\n  }\n};\n\n/**\n * Augmented Object\n * Base class for other classes to extend from\n * @constructor Augmented.Object\n * @param {object} options Object options\n * @memberof Augmented\n */\n\nvar AugmentedObject = function () {\n  function AugmentedObject(options) {\n    _classCallCheck(this, AugmentedObject);\n\n    this._options = {};\n    this._events = {};\n    this._listeningTo = {};\n    this._listenId = {};\n    this._listeners = {};\n\n    if (!this.options) {\n      this._options = {};\n    }\n    if (options) {\n      Object.assign(this._options, options);\n    }\n  }\n\n  _createClass(AugmentedObject, [{\n    key: \"initialize\",\n\n\n    /**\n     * Initialize the object\n     * @method initialize\n     * @returns {object} Returns this context\n     * @memberof Augmented.Object\n     */\n    value: function initialize() {\n      return this;\n    }\n  }, {\n    key: \"trigger\",\n\n\n    /**\n     * Trigger one or many events, firing all bound callbacks. Callbacks are\n     * passed the same arguments as `trigger` is, apart from the event name\n     * (unless you're listening on `\"all\"`, which will cause your callback to\n     * receive the true name of the event as the first argument).\n     * @method trigger\n     * @param {string} name The name of the event\n     * @param {any} args any number of additional arguments\n     * @returns {object} Returns this context\n     * @memberof Augmented.Object\n     */\n    value: function trigger(name) {\n      if (this._events) {\n        var length = Math.max(0, (arguments.length <= 1 ? 0 : arguments.length - 1) - 1);\n        var argsA = Array(length);\n        var i = 0;\n        for (i = 0; i < length; i++) {\n          argsA[i] = arguments.length <= i + 1 + 1 ? undefined : arguments[i + 1 + 1];\n        }\n        eventsApi(triggerApi, this._events, name, void 0, argsA);\n      }\n      return this;\n    }\n  }, {\n    key: \"once\",\n\n\n    /**\n     * Bind an event to only be triggered a single time. After the first time\n     * the callback is invoked, its listener will be removed. If multiple events\n     * are passed in using the space-separated syntax, the handler will fire\n     * once for each event, not once for a combination of all events.\n     * @method once\n     * @param {string} name The name of the event\n     * @param {function} callback The callback to evoke\n     * @param {object} context The context of the callback\n     * @returns {object} Returns this context\n     * @memberof Augmented.Object\n     */\n    value: function once(name, callback, context) {\n      // Map the event into a `{event: once}` object.\n      var events = eventsApi(this._onceMap, {}, name, callback, _bind(this.off, this));\n      if (typeof name === \"string\" && context == null) {\n        callback = void 0;\n      }\n      return this.on(events, callback, context);\n    }\n  }, {\n    key: \"off\",\n\n\n    /**\n     * Remove one or many callbacks. If `context` is null, removes all\n     * callbacks with that function. If `callback` is null, removes all\n     * callbacks for the event. If `name` is null, removes all bound\n     * callbacks for all events.\n     * @method off\n     * @param {string} name The name of the event\n     * @param {function} callback The callback to evoke\n     * @param {object} context The context of the callback\n     * @returns {object} Returns this context\n     * @memberof Augmented.Object\n     */\n    value: function off(name, callback, context) {\n      if (this._events) {\n        this._events = eventsApi(offApi, this._events, name, callback, {\n          context: context,\n          listeners: this._listeners\n        });\n      }\n      return this;\n    }\n  }, {\n    key: \"stopListening\",\n\n\n    /**\n     * Tell this object to stop listening to either specific events ... or\n     * to every object it's currently listening to.\n     * @method stopListening\n     * @param {object} obj The object to stop listening to\n     * @param {string} name The name of the event\n     * @param {function} callback The callback to evoke\n     * @returns {object} Returns this context\n     * @memberof Augmented.Object\n     */\n    value: function stopListening(obj, name, callback) {\n      var listeningTo = this._listeningTo;\n      if (listeningTo) {\n        var ids = obj ? [obj._listenId] : _keys(listeningTo);\n        var i = 0;\n        for (i = 0; i < ids.length; i++) {\n          var listening = listeningTo[ids[i]];\n\n          // If listening doesn't exist, this object is not currently\n          // listening to obj. Break out early.\n          if (!listening) {\n            break;\n          }\n          listening.obj.off(name, callback, this);\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"on\",\n\n\n    /**\n     * Bind an event to a `callback` function. Passing `\"all\"` will bind\n     * the callback to all events fired.\n     * @method on\n     * @param {string} name The name of the event\n     * @param {function} callback The callback to evoke\n     * @param {object} context The context of the callback\n     * @returns {object} Returns this context\n     * @memberof Augmented.Object\n     */\n    value: function on(name, callback, context) {\n      return internalOn(this, name, callback, context);\n    }\n  }, {\n    key: \"listenTo\",\n\n\n    /**\n     * Inversion-of-control versions of `on`. Tell *this* object to listen to\n     * an event in another object... keeping track of what it's listening to\n     * for easier unbinding later.\n     * @method listenTo\n     * @param {object} obj The object to stop listening to\n     * @param {string} name The name of the event\n     * @param {function} callback The callback to evoke\n     * @returns {object} Returns this context\n     * @memberof Augmented.Object\n     */\n    value: function listenTo(obj, name, callback) {\n      if (obj) {\n        var id = obj._listenId || (obj._listenId = _uniqueId(\"l\"));\n        var listeningTo = this._listeningTo || (this._listeningTo = {});\n        var listening = listeningTo[id];\n\n        // This object is not listening to any other events on `obj` yet.\n        // Setup the necessary references to track the listening callbacks.\n        if (!listening) {\n          var thisId = this._listenId || (this._listenId = _uniqueId(\"l\"));\n          listening = listeningTo[id] = { obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0 };\n        }\n\n        // Bind callbacks on obj, and keep track of them on listening.\n        internalOn(obj, name, callback, this, listening);\n      }\n      return this;\n    }\n  }, {\n    key: \"listenToOnce\",\n\n\n    /**\n     * Inversion-of-control versions of `once`.\n     * @method listenToOnce\n     * @param {object} obj The object to stop listening to\n     * @param {string} name The name of the event\n     * @param {function} callback The callback to evoke\n     * @returns {object} Returns this context\n     * @memberof Augmented.Object\n     */\n    value: function listenToOnce(obj, name, callback) {\n      // Map the event into a `{event: once}` object.\n      var events = eventsApi(this._onceMap, {}, name, callback, _bind(this.stopListening, this, obj));\n      return this.listenTo(obj, events);\n    }\n  }, {\n    key: \"_onceMap\",\n\n\n    // Reduces the event callbacks into a map of `{event: onceWrapper}`.\n    // `offer` unbinds the `onceWrapper` after it has been called.\n    value: function _onceMap(map, name, callback, offer) {\n      var _this = this,\n          _arguments2 = arguments;\n\n      if (callback) {\n        var __once = map[name] = _once(function () {\n          offer(name, __once);\n          callback.apply(_this, _arguments2);\n        });\n        __once._callback = callback;\n      }\n      return map;\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this._options;\n    },\n    set: function set(options) {\n      this._options = options;\n    }\n  }, {\n    key: \"events\",\n    get: function get() {\n      return this._events;\n    }\n  }]);\n\n  return AugmentedObject;\n}();\n\n;\n\nexports.default = AugmentedObject;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n* Augmented.Utility.Stack -\n* Standard Stack data structure\n* @constructor Augmented.Utility.Stack\n* @memberof Augmented.Utility\n*/\nvar Stack = function () {\n  function Stack() {\n    _classCallCheck(this, Stack);\n\n    this._stack = [];\n  }\n\n  _createClass(Stack, [{\n    key: \"empty\",\n\n\n    /**\n    * The empty method clears the stack\n    * @method empty\n    * @memberof Augmented.Utility.Stack\n    */\n    value: function empty() {\n      return this._stack.length === 0;\n    }\n  }, {\n    key: \"peek\",\n\n    /**\n    * The peek method returns the first in the stack\n    * @method peek\n    * @memberof Augmented.Utility.Stack\n    * @returns {object} Returns the first object in the stack\n    */\n    value: function peek() {\n      return this._stack[0];\n    }\n  }, {\n    key: \"pop\",\n\n    /**\n    * The pop method returns and removes the first in the stack\n    * @method pop\n    * @memberof Augmented.Utility.Stack\n    * @returns {object} Returns the first object in the stack\n    */\n    value: function pop() {\n      return this._stack.pop();\n    }\n  }, {\n    key: \"push\",\n\n    /**\n    * The push method adds to the stack\n    * @method push\n    * @memberof Augmented.Utility.Stack\n    * @param {object} item The item to push to the stack\n    */\n    value: function push(item) {\n      this._stack.push(item);\n    }\n  }, {\n    key: \"search\",\n\n    /**\n    * The search method returns where in the stack an item exists\n    * @method search\n    * @memberof Augmented.Utility.Stack\n    * @returns {number} Returns the index of the item\n    */\n    value: function search(item) {\n      return this._stack.indexOf(item);\n    }\n  }, {\n    key: \"size\",\n\n    /**\n    * The size method returns the size of the stack\n    * @method size\n    * @memberof Augmented.Utility.Stack\n    * @returns {number} Returns the size of the stack\n    */\n    value: function size() {\n      return this._stack.length;\n    }\n  }, {\n    key: \"clear\",\n\n    /**\n    * The clear method clears the stack\n    * @method clear\n    * @memberof Augmented.Utility.Stack\n    */\n    value: function clear() {\n      this._stack.splice(0, this._stack.length);\n    }\n  }, {\n    key: \"toArray\",\n\n    /**\n    * The toArray method returns the stack as an array\n    * @method toArray\n    * @memberof Augmented.Utility.Stack\n    * @returns {array} Returns the stack as an array\n    */\n    value: function toArray() {\n      return this._stack;\n    }\n  }]);\n\n  return Stack;\n}();\n\n;\n\nexports.default = Stack;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _arguments = arguments;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Utility Package -\n * Small Utilities\n * @namespace Augmented.Utility\n * @memberof Augmented\n */\n\n/**\n * Shuffles an Array with Fisher-Yates Shuffle algorithm\n * @constructor Augmented.Utility.Shuffle\n * @memberof Augmented.Utility\n * @param {array} array The array to shuffle\n * @returns {array} A new shuffled array\n */\nvar shuffle = exports.shuffle = function shuffle(array) {\n  var nArray = array.slice(0),\n      l = array.length;\n  var i = 0,\n      temp = void 0,\n      j = void 0;\n  for (i = l - 1; i > 0; i--) {\n    j = Math.floor(Math.random() * (i + 1));\n    temp = nArray[i];\n    nArray[i] = nArray[j];\n    nArray[j] = temp;\n  }\n  return nArray;\n};\n\n/**\n * Prints an object nicely\n * @constructor Augmented.Utility.PrettyPrint\n * @memberof Augmented.Utility\n * @param {object} obj The object to print\n * @param {boolean} spaces Use spaces instead of tabs\n * @returns {number} number The number of spaces to pad\n */\nvar prettyPrint = exports.prettyPrint = function prettyPrint(obj, spaces, number) {\n  var x = \"\\t\";\n  if (spaces) {\n    x = \" \".repeat(number);\n  }\n  return JSON.stringify(obj, null, x);\n};\n\n/**\n * Sorts an array of objects by propery in object\n * @constructor Augmented.Utility.sortObjects\n * @memberof Augmented.Utility\n * @param {array} array The object array to sort\n * @param {object} key The property to sort by\n * @returns {array} The sorted array\n */\nvar sortObjects = exports.sortObjects = function sortObjects(array, key) {\n  return array.sort(function (a, b) {\n    var x = a[key],\n        y = b[key];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n};\n\n/**\n * Performs a binary search on the host array. vs indexOf<br/>\n * Binary Search is a complexity of <em>O(n log n)</em> vs <em>O(n)</em> with indexOf\n * @constructor Augmented.Utility.BinarySearch\n * @memberof Augmented.Utility\n * @param {Array} arr The array.\n * @param {Any} find The item to search for within the array.\n * @param {function} comparator The comparator to use\n * @returns {Number} The index of the element which defaults to -1 when not found.\n */\nvar binarySearch = exports.binarySearch = function binarySearch(arr, find, comparator) {\n  var low = 0,\n      high = arr.length - 1,\n      i = void 0,\n      comparison = void 0;\n\n  while (low <= high) {\n    i = Math.floor((low + high) / 2);\n    comparison = comparator(arr[i], find);\n    if (comparison < 0) {\n      low = i + 1;continue;\n    }\n    if (comparison > 0) {\n      high = i - 1;continue;\n    }\n    return i;\n  }\n  return null;\n};\n\n/**\n * Quick Sort implimentation for Arrays -\n * @constructor Augmented.Utility.QuickSort\n * @memberof Augmented.Utility\n * @param {Array} arr Array to Sort\n * @returns {Array} Returns a sorted array\n */\nvar quickSort = exports.quickSort = function quickSort(arr) {\n  //if array is empty\n  if (arr.length === 0) {\n    return [];\n  }\n\n  var i = 1;\n  var l = arr.length,\n      left = [],\n      right = [],\n      pivot = arr[0];\n  //go through each element in array\n  for (i = 1; i < l; i++) {\n    if (arr[i] < pivot) {\n      left.push(arr[i]);\n    } else {\n      right.push(arr[i]);\n    }\n  }\n  return quickSort(left).concat(pivot, quickSort(right));\n};\n\n/**\n * Augmented.Utility.TransformerType <br/>\n * Transformer type for use in the transformer\n * @enum {Symbol} Augmented.Utility.TransformerType\n * @name Augmented.Utility.TransformerType\n * @memberof Augmented.Utility\n * @property {Symbol} String Standard String\n * @property {Symbol} Integer Integer\n * @property {Symbol} Number Any number\n * @property {Symbol} Boolean True/False\n * @property {Symbol} Array Stanrdard Array\n * @property {Symbol} Object Any Object\n * @property {Symbol} Null Null\n */\nvar TransformerType = exports.TransformerType = {};\nTransformerType.STRING = Symbol(\"String\");\nTransformerType.INTEGER = Symbol(\"Integer\");\nTransformerType.NUMBER = Symbol(\"Number\");\nTransformerType.BOOLEAN = Symbol(\"Boolean\");\nTransformerType.ARRAY = Symbol(\"Array\");\nTransformerType.OBJECT = Symbol(\"Object\");\nTransformerType.NULL = Symbol(\"Null\");\n\n/**\n * Augmented.Utility.Transformer <br/>\n * Transform an object, type, or array to another type, object, or array\n * @namespace Augmented.Utility.Transformer\n * @memberof Augmented.Utility\n */\n\nvar Transformer = exports.Transformer = function () {\n  function Transformer() {\n    _classCallCheck(this, Transformer);\n  }\n\n  /**\n   * The transformer type enum\n   * @propery type The transformer type enum\n   * @type {Augmented.Utility.TransformerType}\n   * @memberof Augmented.Utility.Transformer\n   */\n\n\n  _createClass(Transformer, null, [{\n    key: \"transform\",\n\n\n    /**\n     * Transform an object, primitive, or array to another object, primitive, or array\n     * @method transform\n     * @param {object} source Source primitive to transform\n     * @param {Augmented.Utility.TransformerType} type Type to transform to\n     * @memberof Augmented.Utility.Transformer\n     * @returns {object} returns a transformed object or primitive\n     */\n    value: function transform(source, type) {\n      var out = null;\n      switch (type) {\n        case TransformerType.STRING:\n          if ((typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n            out = JSON.stringify(source);\n          } else {\n            out = String(source);\n          }\n          break;\n        case TransformerType.INTEGER:\n          out = parseInt(source);\n          break;\n        case TransformerType.NUMBER:\n          out = Number(source);\n          break;\n        case TransformerType.BOOLEAN:\n          out = Boolean(source);\n          break;\n        case TransformerType.ARRAY:\n          if (!Array.isArray(source)) {\n            out = [];\n            out[0] = source;\n          } else {\n            out = source;\n          }\n          break;\n        case TransformerType.OBJECT:\n          if ((typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) !== \"object\") {\n            out = {};\n            out[source] = source;\n          } else {\n            out = source;\n          }\n          break;\n      }\n      return out;\n    }\n  }, {\n    key: \"isType\",\n\n\n    /**\n     * Returns a Augmented.Utility.TransformerType of a passed object\n     * @method isType\n     * @memberof Augmented.Utility.Transformer\n     * @param {object} source The source primitive\n     * @returns {Augmented.Utility.TransformerType} type of source as Augmented.Utility.TransformerType\n     */\n    value: function isType(source) {\n      if (source === null) {\n        return TransformerType.NULL;\n      } else if (typeof source === \"string\") {\n        return TransformerType.STRING;\n      } else if (typeof source === \"number\") {\n        return TransformerType.NUMBER;\n      } else if (typeof source === \"boolean\") {\n        return TransformerType.BOOLEAN;\n      } else if (Array.isArray(source)) {\n        return TransformerType.ARRAY;\n      } else if ((typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n        return TransformerType.OBJECT;\n      }\n    }\n  }]);\n\n  return Transformer;\n}();\n\nTransformer.type = TransformerType;\n;\n\n/**\n * Wrap method to handle wrapping functions (simular to _.wrap)\n * @method wrap\n * @memberof Augmented.Utility\n */\nvar wrap = exports.wrap = function wrap(fn, _wrap) {\n  return function () {\n    return _wrap.apply(undefined, [fn].concat(Array.prototype.slice.call(_arguments)));\n  };\n};\n\n/**\n * filter an oject from array of values\n *\n * @method filterObject\n * @param {object} object Object to filter\n * @param {array} keys keys to filter from the object\n * @returns {object} returns a new object with only these keys\n * @memberof Augmented.Utility\n */\nvar filterObject = exports.filterObject = function filterObject(object, keys) {\n  var newObject = {};\n  if (object && keys) {\n    var l = keys.length;\n    var i = 0;\n    for (i = 0; i < l; i++) {\n      newObject[keys[i]] = object[keys[i]];\n    }\n  }\n  return newObject;\n};\n\nvar extend = exports.extend = function extend() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var i = 0;\n  var l = args.length;\n  for (i = 1; i < l; i++) {\n    var key = void 0;\n    for (key in args[i]) {\n      if (args[i].hasOwnProperty(key)) {\n        args[0][key] = args[i][key];\n      }\n    }\n  }\n  return args[0];\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _arguments = arguments;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _utility = __webpack_require__(5);\n\nvar Utility = _interopRequireWildcard(_utility);\n\nvar _logger = __webpack_require__(1);\n\nvar Logger = _interopRequireWildcard(_logger);\n\nvar _object = __webpack_require__(3);\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _map = __webpack_require__(2);\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _isString = __webpack_require__(0);\n\nvar _isString2 = _interopRequireDefault(_isString);\n\nvar _stack = __webpack_require__(4);\n\nvar _stack2 = _interopRequireDefault(_stack);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * Augmented.js 2 - The Core UI Component and package\n *\n * @author Bob Warren\n *\n * @module Augmented\n * @version 2.0.0\n * @license Apache-2.0\n */\nvar Augmented = {};\nAugmented.Utility = Utility;\nAugmented.Utility.Map = _map2.default;\nAugmented.Utility.Stack = _stack2.default;\nAugmented.Logger = Logger;\nAugmented.Object = _object2.default;\n\n/**\n * The standard version property\n * @constant VERSION\n */\nAugmented.VERSION = \"2.0.0\";\n/**\n * A codename for internal use\n * @constant codename\n */\nAugmented.codename = \"JC Denton\";\n/**\n * A release name to help with identification of minor releases\n * @constant releasename\n */\nAugmented.releasename = \"UNATCO\";\n\n/**\n * Augmented underscore (if it exists from Backbone.js)\n * @module _\n * @name _\n * @memberof Augmented\n */\nAugmented._ = {};\n\n/**\n * Augmented underscore (if it exists from Backbone.js)\n * @module $\n * @name $\n * @memberof Augmented\n */\nAugmented.$ = {};\n\n/**\n * Augmented.Configuration - a set of configuration properties for the framework\n * @enum Configuration\n * @memberof Augmented\n * @property {string} LoggerLevel The level of the framework internal logger\n * @property {string} MessageBundle - the base name for messages in the framework (default: Messages)\n * @property {number} AsynchronousQueueTimeout the default milisecond timeout (default: 2000)\n * @property {number} ApplicationInitProcessTimeout the application init even timeout (default: 1000)\n * @todo change logger level to error\n */\nAugmented.Configuration = {\n  LoggerLevel: \"info\",\n  MessageBundle: \"Messages\",\n  AsynchronousQueueTimeout: 2000,\n  ApplicationInitProcessTimeout: 1000\n};\n\n/*\n * Base functionality\n * Set of base capabilities used throughout the framework\n */\n\n/**\n * Augmented.has\n * @method has\n * @memberof Augmented\n * @param {object} obj The input object\n * @param {object} key The test key\n * @returns {boolean} Returns true of the key exists\n */\nAugmented.has = function (obj, key) {\n  return obj !== null && hasOwnProperty.call(obj, key);\n};\n\n/**\n * Augmented.isObject\n * @method isObject\n * @memberof Augmented\n * @param {object} obj The input object\n * @returns {boolean} Returns true of the param is an object\n */\nAugmented.isObject = function (obj) {\n  var type = typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n  return type === \"function\" || type === \"object\" && !!obj;\n};\n\n/**\n * Augmented.allKeys\n * @method allKeys\n * @memberof Augmented\n * @param {object} obj The input object\n * @returns {array} Returns the array of ALL keys including prototyped\n */\nAugmented.allKeys = function (obj) {\n  if (!Augmented.isObject(obj)) return [];\n  return Object.getOwnPropertyNames(obj);\n};\n\nvar result = function result(prototype) {\n  if (!Augmented.isObject(prototype)) {\n    return {};\n  }\n  return Object.create(prototype);\n};\n\n/**\n * Augmented.create\n * @method create\n * @memberof Augmented\n * @param {object} prototype The input prototype\n * @param {object} props The properties (optional)\n * @returns {object} Returns the created object\n */\nAugmented.create = function (prototype, props) {\n  var o = result(prototype);\n  if (props) {\n    Object.assign(o, props);\n  }\n  return o;\n};\n\n// Map from CRUD to HTTP for our default sync implementation.\nvar methodMap = {\n  \"create\": \"POST\",\n  \"update\": \"PUT\",\n  \"patch\": \"PATCH\",\n  \"delete\": \"DELETE\",\n  \"read\": \"GET\"\n};\n\n/**\n * Augmented.sync - Base sync method that can pass special augmented features\n * @method sync\n * @memberof Augmented\n */\nAugmented.sync = function (method, model, options) {\n  var type = methodMap[method];\n\n  if (!options) {\n    options = {};\n  }\n\n  // Default JSON-request options.\n  var params = { type: type, dataType: \"json\" };\n\n  // Ensure that we have a URL.\n  if (!options.url) {\n    if (model.url) {\n      if (Augmented.isFunction(model.url)) {\n        params.url = model.url();\n      } else {\n        params.url = model.url;\n      }\n    } else {\n      throw new Error(\"A \\\"url\\\" property or function must be specified\");\n    }\n  }\n\n  // Ensure that we have the appropriate request data.\n  if (options.data == null && model && (method === \"create\" || method === \"update\" || method === \"patch\")) {\n    params.contentType = \"application/json\";\n    params.data = JSON.stringify(options.attrs || model.toJSON(options));\n  }\n\n  // Don't process data on a non-GET request.\n  if (params.type !== \"GET\") {\n    params.processData = false;\n  }\n\n  // Pass along `textStatus` and `errorThrown` from jQuery.\n  var error = options.error;\n  options.error = function (xhr, textStatus, errorThrown) {\n    options.textStatus = textStatus;\n    options.errorThrown = errorThrown;\n    if (error) {\n      error.call(options.context, xhr, textStatus, errorThrown);\n    }\n  };\n\n  // Make the request, allowing the user to override any Ajax options.\n  var xhr = options.xhr = Augmented.ajax(Augmented.Utility.extend(params, options));\n  model.trigger(\"request\", model, xhr, options);\n  return xhr;\n};\n\n/**\n* Augmented.isFunction -\n* returns true if called name is a function\n* simular to jQuery .isFunction method\n* @method Augmented.isFunction\n* @param {function} name The name of the function to test\n* @memberof Augmented\n* @returns true if called name is a function\n*/\nAugmented.isFunction = function (name) {\n  return Object.prototype.toString.call(name) == \"[object Function]\";\n};\n\n// imported\nAugmented.isString = _isString2.default;\n\n/**\n* Augmented.result - returns named property in an object\n* simular to underscore .result method\n* @function result\n* @memberof Augmented\n* @returns named property in an object\n*/\nAugmented.result = function (object, property) {\n  if (object === null) return;\n  var value = object[property];\n  return Augmented.isFunction(value) ? value.call(object) : value;\n};\n\n/**\n * Array.has - returns is a property is in the array (very fast return)\n * @function arrayhas\n * @memberof Augmented\n * @param {array} arr Source array\n * @param {object} key Key to test for\n * @returns true if property is included in an array\n */\nAugmented.arrayHas = function (arr, key) {\n  return arr.indexOf(key) !== -1;\n};\n\n/**\n * exec method - Execute a function by name\n * @method exec\n * @memberof Augmented\n * @param {string} functionName The name of the function\n * @param {object} context The context to call from\n * @param (object) args Arguments\n */\nAugmented.exec = function (functionName, context /*, args */) {\n  var args = Array.prototype.slice.call(_arguments, 2),\n      namespaces = functionName.split(\".\"),\n      func = namespaces.pop(),\n      l = namespaces.length;\n  var i = 0;\n  for (i = 0; i < l; i++) {\n    context = context[namespaces[i]];\n  }\n  return context[func].apply(context, args);\n};\n\n/**\n * Augmented.isDefined - Checks and returns if a passed variable is defined\n * @method isDefined\n * @memberof Augmented\n * @param {string} variable to check\n * @returns {boolean} true if value is defined\n */\nAugmented.isDefined = function (val) {\n  return typeof val != \"undefined\";\n};\n\nexports.default = Augmented;\n\n//module.exports = Augmented;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as the internal argument placeholder. */\nvar PLACEHOLDER = '__lodash_placeholder__';\n\n/** Used to compose bitmasks for function metadata. */\nvar BIND_FLAG = 1,\n    BIND_KEY_FLAG = 2,\n    CURRY_BOUND_FLAG = 4,\n    CURRY_FLAG = 8,\n    CURRY_RIGHT_FLAG = 16,\n    PARTIAL_FLAG = 32,\n    PARTIAL_RIGHT_FLAG = 64,\n    ARY_FLAG = 128,\n    REARG_FLAG = 256,\n    FLIP_FLAG = 512;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991,\n    MAX_INTEGER = 1.7976931348623157e+308,\n    NAN = 0 / 0;\n\n/** Used to associate wrap methods with their bit flags. */\nvar wrapFlags = [\n  ['ary', ARY_FLAG],\n  ['bind', BIND_FLAG],\n  ['bindKey', BIND_KEY_FLAG],\n  ['curry', CURRY_FLAG],\n  ['curryRight', CURRY_RIGHT_FLAG],\n  ['flip', FLIP_FLAG],\n  ['partial', PARTIAL_FLAG],\n  ['partialRight', PARTIAL_RIGHT_FLAG],\n  ['rearg', REARG_FLAG]\n];\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to match wrap detail comments. */\nvar reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n    reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n    reSplitDetails = /,? & /;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array ? array.length : 0;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  if (value !== value) {\n    return baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * Gets the number of `placeholder` occurrences in `array`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} placeholder The placeholder to search for.\n * @returns {number} Returns the placeholder count.\n */\nfunction countHolders(array, placeholder) {\n  var length = array.length,\n      result = 0;\n\n  while (length--) {\n    if (array[length] === placeholder) {\n      result++;\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Replaces all `placeholder` elements in `array` with an internal placeholder\n * and returns an array of their indexes.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {*} placeholder The placeholder to replace.\n * @returns {Array} Returns the new array of placeholder indexes.\n */\nfunction replaceHolders(array, placeholder) {\n  var index = -1,\n      length = array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (value === placeholder || value === PLACEHOLDER) {\n      array[index] = PLACEHOLDER;\n      result[resIndex++] = index;\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/* Used to set `toString` methods. */\nvar defineProperty = (function() {\n  var func = getNative(Object, 'defineProperty'),\n      name = getNative.name;\n\n  return (name && name.length > 2) ? func : undefined;\n}());\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = array;\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Creates an array that is the composition of partially applied arguments,\n * placeholders, and provided arguments into a single array of arguments.\n *\n * @private\n * @param {Array} args The provided arguments.\n * @param {Array} partials The arguments to prepend to those provided.\n * @param {Array} holders The `partials` placeholder indexes.\n * @params {boolean} [isCurried] Specify composing for a curried function.\n * @returns {Array} Returns the new array of composed arguments.\n */\nfunction composeArgs(args, partials, holders, isCurried) {\n  var argsIndex = -1,\n      argsLength = args.length,\n      holdersLength = holders.length,\n      leftIndex = -1,\n      leftLength = partials.length,\n      rangeLength = nativeMax(argsLength - holdersLength, 0),\n      result = Array(leftLength + rangeLength),\n      isUncurried = !isCurried;\n\n  while (++leftIndex < leftLength) {\n    result[leftIndex] = partials[leftIndex];\n  }\n  while (++argsIndex < holdersLength) {\n    if (isUncurried || argsIndex < argsLength) {\n      result[holders[argsIndex]] = args[argsIndex];\n    }\n  }\n  while (rangeLength--) {\n    result[leftIndex++] = args[argsIndex++];\n  }\n  return result;\n}\n\n/**\n * This function is like `composeArgs` except that the arguments composition\n * is tailored for `_.partialRight`.\n *\n * @private\n * @param {Array} args The provided arguments.\n * @param {Array} partials The arguments to append to those provided.\n * @param {Array} holders The `partials` placeholder indexes.\n * @params {boolean} [isCurried] Specify composing for a curried function.\n * @returns {Array} Returns the new array of composed arguments.\n */\nfunction composeArgsRight(args, partials, holders, isCurried) {\n  var argsIndex = -1,\n      argsLength = args.length,\n      holdersIndex = -1,\n      holdersLength = holders.length,\n      rightIndex = -1,\n      rightLength = partials.length,\n      rangeLength = nativeMax(argsLength - holdersLength, 0),\n      result = Array(rangeLength + rightLength),\n      isUncurried = !isCurried;\n\n  while (++argsIndex < rangeLength) {\n    result[argsIndex] = args[argsIndex];\n  }\n  var offset = argsIndex;\n  while (++rightIndex < rightLength) {\n    result[offset + rightIndex] = partials[rightIndex];\n  }\n  while (++holdersIndex < holdersLength) {\n    if (isUncurried || argsIndex < argsLength) {\n      result[offset + holders[holdersIndex]] = args[argsIndex++];\n    }\n  }\n  return result;\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Creates a function that wraps `func` to invoke it with the optional `this`\n * binding of `thisArg`.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createBind(func, bitmask, thisArg) {\n  var isBind = bitmask & BIND_FLAG,\n      Ctor = createCtor(func);\n\n  function wrapper() {\n    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n    return fn.apply(isBind ? thisArg : this, arguments);\n  }\n  return wrapper;\n}\n\n/**\n * Creates a function that produces an instance of `Ctor` regardless of\n * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n *\n * @private\n * @param {Function} Ctor The constructor to wrap.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createCtor(Ctor) {\n  return function() {\n    // Use a `switch` statement to work with class constructors. See\n    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n    // for more details.\n    var args = arguments;\n    switch (args.length) {\n      case 0: return new Ctor;\n      case 1: return new Ctor(args[0]);\n      case 2: return new Ctor(args[0], args[1]);\n      case 3: return new Ctor(args[0], args[1], args[2]);\n      case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n    }\n    var thisBinding = baseCreate(Ctor.prototype),\n        result = Ctor.apply(thisBinding, args);\n\n    // Mimic the constructor's `return` behavior.\n    // See https://es5.github.io/#x13.2.2 for more details.\n    return isObject(result) ? result : thisBinding;\n  };\n}\n\n/**\n * Creates a function that wraps `func` to enable currying.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n * @param {number} arity The arity of `func`.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createCurry(func, bitmask, arity) {\n  var Ctor = createCtor(func);\n\n  function wrapper() {\n    var length = arguments.length,\n        args = Array(length),\n        index = length,\n        placeholder = getHolder(wrapper);\n\n    while (index--) {\n      args[index] = arguments[index];\n    }\n    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n      ? []\n      : replaceHolders(args, placeholder);\n\n    length -= holders.length;\n    if (length < arity) {\n      return createRecurry(\n        func, bitmask, createHybrid, wrapper.placeholder, undefined,\n        args, holders, undefined, undefined, arity - length);\n    }\n    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n    return apply(fn, this, args);\n  }\n  return wrapper;\n}\n\n/**\n * Creates a function that wraps `func` to invoke it with optional `this`\n * binding of `thisArg`, partial application, and currying.\n *\n * @private\n * @param {Function|string} func The function or method name to wrap.\n * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {Array} [partials] The arguments to prepend to those provided to\n *  the new function.\n * @param {Array} [holders] The `partials` placeholder indexes.\n * @param {Array} [partialsRight] The arguments to append to those provided\n *  to the new function.\n * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n * @param {Array} [argPos] The argument positions of the new function.\n * @param {number} [ary] The arity cap of `func`.\n * @param {number} [arity] The arity of `func`.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n  var isAry = bitmask & ARY_FLAG,\n      isBind = bitmask & BIND_FLAG,\n      isBindKey = bitmask & BIND_KEY_FLAG,\n      isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),\n      isFlip = bitmask & FLIP_FLAG,\n      Ctor = isBindKey ? undefined : createCtor(func);\n\n  function wrapper() {\n    var length = arguments.length,\n        args = Array(length),\n        index = length;\n\n    while (index--) {\n      args[index] = arguments[index];\n    }\n    if (isCurried) {\n      var placeholder = getHolder(wrapper),\n          holdersCount = countHolders(args, placeholder);\n    }\n    if (partials) {\n      args = composeArgs(args, partials, holders, isCurried);\n    }\n    if (partialsRight) {\n      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n    }\n    length -= holdersCount;\n    if (isCurried && length < arity) {\n      var newHolders = replaceHolders(args, placeholder);\n      return createRecurry(\n        func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n        args, newHolders, argPos, ary, arity - length\n      );\n    }\n    var thisBinding = isBind ? thisArg : this,\n        fn = isBindKey ? thisBinding[func] : func;\n\n    length = args.length;\n    if (argPos) {\n      args = reorder(args, argPos);\n    } else if (isFlip && length > 1) {\n      args.reverse();\n    }\n    if (isAry && ary < length) {\n      args.length = ary;\n    }\n    if (this && this !== root && this instanceof wrapper) {\n      fn = Ctor || createCtor(fn);\n    }\n    return fn.apply(thisBinding, args);\n  }\n  return wrapper;\n}\n\n/**\n * Creates a function that wraps `func` to invoke it with the `this` binding\n * of `thisArg` and `partials` prepended to the arguments it receives.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} partials The arguments to prepend to those provided to\n *  the new function.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createPartial(func, bitmask, thisArg, partials) {\n  var isBind = bitmask & BIND_FLAG,\n      Ctor = createCtor(func);\n\n  function wrapper() {\n    var argsIndex = -1,\n        argsLength = arguments.length,\n        leftIndex = -1,\n        leftLength = partials.length,\n        args = Array(leftLength + argsLength),\n        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n    while (++leftIndex < leftLength) {\n      args[leftIndex] = partials[leftIndex];\n    }\n    while (argsLength--) {\n      args[leftIndex++] = arguments[++argsIndex];\n    }\n    return apply(fn, isBind ? thisArg : this, args);\n  }\n  return wrapper;\n}\n\n/**\n * Creates a function that wraps `func` to continue currying.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n * @param {Function} wrapFunc The function to create the `func` wrapper.\n * @param {*} placeholder The placeholder value.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {Array} [partials] The arguments to prepend to those provided to\n *  the new function.\n * @param {Array} [holders] The `partials` placeholder indexes.\n * @param {Array} [argPos] The argument positions of the new function.\n * @param {number} [ary] The arity cap of `func`.\n * @param {number} [arity] The arity of `func`.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n  var isCurry = bitmask & CURRY_FLAG,\n      newHolders = isCurry ? holders : undefined,\n      newHoldersRight = isCurry ? undefined : holders,\n      newPartials = isCurry ? partials : undefined,\n      newPartialsRight = isCurry ? undefined : partials;\n\n  bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\n  bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\n\n  if (!(bitmask & CURRY_BOUND_FLAG)) {\n    bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n  }\n\n  var result = wrapFunc(func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity);\n  result.placeholder = placeholder;\n  return setWrapToString(result, func, bitmask);\n}\n\n/**\n * Creates a function that either curries or invokes `func` with optional\n * `this` binding and partially applied arguments.\n *\n * @private\n * @param {Function|string} func The function or method name to wrap.\n * @param {number} bitmask The bitmask flags.\n *  The bitmask may be composed of the following flags:\n *     1 - `_.bind`\n *     2 - `_.bindKey`\n *     4 - `_.curry` or `_.curryRight` of a bound function\n *     8 - `_.curry`\n *    16 - `_.curryRight`\n *    32 - `_.partial`\n *    64 - `_.partialRight`\n *   128 - `_.rearg`\n *   256 - `_.ary`\n *   512 - `_.flip`\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {Array} [partials] The arguments to be partially applied.\n * @param {Array} [holders] The `partials` placeholder indexes.\n * @param {Array} [argPos] The argument positions of the new function.\n * @param {number} [ary] The arity cap of `func`.\n * @param {number} [arity] The arity of `func`.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n  var isBindKey = bitmask & BIND_KEY_FLAG;\n  if (!isBindKey && typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var length = partials ? partials.length : 0;\n  if (!length) {\n    bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\n    partials = holders = undefined;\n  }\n  ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n  arity = arity === undefined ? arity : toInteger(arity);\n  length -= holders ? holders.length : 0;\n\n  if (bitmask & PARTIAL_RIGHT_FLAG) {\n    var partialsRight = partials,\n        holdersRight = holders;\n\n    partials = holders = undefined;\n  }\n\n  var newData = [\n    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n    argPos, ary, arity\n  ];\n\n  func = newData[0];\n  bitmask = newData[1];\n  thisArg = newData[2];\n  partials = newData[3];\n  holders = newData[4];\n  arity = newData[9] = newData[9] == null\n    ? (isBindKey ? 0 : func.length)\n    : nativeMax(newData[9] - length, 0);\n\n  if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {\n    bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);\n  }\n  if (!bitmask || bitmask == BIND_FLAG) {\n    var result = createBind(func, bitmask, thisArg);\n  } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {\n    result = createCurry(func, bitmask, arity);\n  } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {\n    result = createPartial(func, bitmask, thisArg, partials);\n  } else {\n    result = createHybrid.apply(undefined, newData);\n  }\n  return setWrapToString(result, func, bitmask);\n}\n\n/**\n * Gets the argument placeholder value for `func`.\n *\n * @private\n * @param {Function} func The function to inspect.\n * @returns {*} Returns the placeholder value.\n */\nfunction getHolder(func) {\n  var object = func;\n  return object.placeholder;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Extracts wrapper details from the `source` body comment.\n *\n * @private\n * @param {string} source The source to inspect.\n * @returns {Array} Returns the wrapper details.\n */\nfunction getWrapDetails(source) {\n  var match = source.match(reWrapDetails);\n  return match ? match[1].split(reSplitDetails) : [];\n}\n\n/**\n * Inserts wrapper `details` in a comment at the top of the `source` body.\n *\n * @private\n * @param {string} source The source to modify.\n * @returns {Array} details The details to insert.\n * @returns {string} Returns the modified source.\n */\nfunction insertWrapDetails(source, details) {\n  var length = details.length,\n      lastIndex = length - 1;\n\n  details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n  details = details.join(length > 2 ? ', ' : ' ');\n  return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Reorder `array` according to the specified indexes where the element at\n * the first index is assigned as the first element, the element at\n * the second index is assigned as the second element, and so on.\n *\n * @private\n * @param {Array} array The array to reorder.\n * @param {Array} indexes The arranged array indexes.\n * @returns {Array} Returns `array`.\n */\nfunction reorder(array, indexes) {\n  var arrLength = array.length,\n      length = nativeMin(indexes.length, arrLength),\n      oldArray = copyArray(array);\n\n  while (length--) {\n    var index = indexes[length];\n    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n  }\n  return array;\n}\n\n/**\n * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n * with wrapper details in a comment at the top of the source body.\n *\n * @private\n * @param {Function} wrapper The function to modify.\n * @param {Function} reference The reference function.\n * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n * @returns {Function} Returns `wrapper`.\n */\nvar setWrapToString = !defineProperty ? identity : function(wrapper, reference, bitmask) {\n  var source = (reference + '');\n  return defineProperty(wrapper, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)))\n  });\n};\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Updates wrapper `details` based on `bitmask` flags.\n *\n * @private\n * @returns {Array} details The details to modify.\n * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n * @returns {Array} Returns `details`.\n */\nfunction updateWrapDetails(details, bitmask) {\n  arrayEach(wrapFlags, function(pair) {\n    var value = '_.' + pair[0];\n    if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n      details.push(value);\n    }\n  });\n  return details.sort();\n}\n\n/**\n * Creates a function that invokes `func` with the `this` binding of `thisArg`\n * and `partials` prepended to the arguments it receives.\n *\n * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n * may be used as a placeholder for partially applied arguments.\n *\n * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n * property of bound functions.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to bind.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {...*} [partials] The arguments to be partially applied.\n * @returns {Function} Returns the new bound function.\n * @example\n *\n * function greet(greeting, punctuation) {\n *   return greeting + ' ' + this.user + punctuation;\n * }\n *\n * var object = { 'user': 'fred' };\n *\n * var bound = _.bind(greet, object, 'hi');\n * bound('!');\n * // => 'hi fred!'\n *\n * // Bound with placeholders.\n * var bound = _.bind(greet, object, _, '!');\n * bound('hi');\n * // => 'hi fred!'\n */\nvar bind = baseRest(function(func, thisArg, partials) {\n  var bitmask = BIND_FLAG;\n  if (partials.length) {\n    var holders = replaceHolders(partials, getHolder(bind));\n    bitmask |= PARTIAL_FLAG;\n  }\n  return createWrap(func, bitmask, thisArg, partials, holders);\n});\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n// Assign default placeholders.\nbind.placeholder = {};\n\nmodule.exports = bind;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// augmented2.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2ca07af6c394fd6cf234","/**\n * Augmented.isString -\n * checks if a value is a String\n * @method isString\n * @memberof Augmented\n * @param {string} variable to check\n * @returns {boolean} true if value is a string\n */\nconst isString = (val) => {\n  return (typeof val === \"string\") || ((!!val && typeof val === \"object\") && Object.prototype.toString.call(val) === \"[object String]\");\n};\n\nexport default isString;\n\n\n\n// WEBPACK FOOTER //\n// ./src/isString.js","/**\n * A Logger package\n * @namespace Augmented.Logger\n * @memberof Augmented\n */\n\nconst pad = (p, str, padLeft) => {\n  if (typeof str === \"undefined\") {\n    return p;\n  }\n  if (padLeft) {\n    return (p + str).slice(-p.length);\n  } else {\n    return (p + pad).substring(0, p.length);\n  }\n};\n\n/**\n * Augmented.Logger.Type\n * @name Augmented.Logger.Type\n * @enum {Symbol}\n * @memberof Augmented.Logger\n * @property {Symbol} CONSOLE The console logger (HTML5 console)\n * @property {Symbol} COLOR_CONSOLE The color console logger (HTML5 console)\n * @property {Symbol} REST A REST-based logger\n * @memberof Augmented.Logger\n */\nexport const Type = {};\nType.CONSOLE = Symbol(\"console\");\nType.COLOR_CONSOLE = Symbol(\"colorConsole\");\nType.REST = Symbol(\"rest\");\n\n/**\n * Augmented.Logger.Level\n * @name Augmented.Logger.Level\n * @enum {Symbol}\n * @property {Symbol} INFO The Info level\n * @property {Symbol} DEBUG The debug level\n * @property {Symbol} ERROR The error level\n * @property {Symbol} WARN The warning level\n * @memberof Augmented.Logger\n */\nexport const Level = {};\nLevel.INFO = Symbol(\"info\");\nLevel.DEBUG = Symbol(\"debug\");\nLevel.ERROR = Symbol(\"error\");\nLevel.WARN = Symbol(\"warn\");\n\n/**\n * Augmented Abstract Logger\n * @constructor Augmented.AbstractLogger\n * @param {Augmented.Logger.Level} l The level to initialize the logger with\n * @abstract\n * @memberof Augmented\n */\nclass AbstractLogger {\n  constructor(l) {\n    this.loggerLevel = (l) ? l : Level.INFO;\n  };\n  TIME_SEPERATOR = \":\";\n  DATE_SEPERATOR = \"-\";\n  OPEN_GROUP = \" [ \";\n  CLOSE_GROUP = \" ] \";\n  label = Level;\n\n  _getLogTime() {\n    const now = new Date();\n    const s = `${now.getFullYear()}${this.DATE_SEPERATOR}${(now.getMonth() + 1)}${this.DATE_SEPERATOR}${now.getDate()} ${now.getHours()}${this.TIME_SEPERATOR}${now.getMinutes()}${this.TIME_SEPERATOR}${now.getSeconds()}${this.TIME_SEPERATOR}${now.getMilliseconds()}`;\n    return pad(\"                        \", s, false);\n  };\n\n  /**\n   * log a message\n   * @method log\n   * @memberof AbstractLogger\n   * @param {string} message The message to log\n   * @param {Augmented.Logger.Level} level The level of the log message\n   * @returns {string} The message\n   */\n  log(message, level) {\n    let m = \"\";\n    if (message) {\n      if (!level) {\n        level = Level.INFO;\n      }\n      if (this.loggerLevel === Level.DEBUG && level === Level.DEBUG) {\n        m = this._logMe(`${this._getLogTime()}${this.OPEN_GROUP}DEBUG${this.CLOSE_GROUP}${message}`, level);\n      } else if (level === Level.ERROR) {\n        m = this._logMe(`${this._getLogTime()}${this.OPEN_GROUP}ERROR${this.CLOSE_GROUP}${message}`, level);\n      } else if (level === Level.WARN) {\n        m = this._logMe(`${this._getLogTime()}${this.OPEN_GROUP}WARN ${this.CLOSE_GROUP}${message}`, level);\n      } else if (this.loggerLevel === Level.DEBUG || this.loggerLevel === Level.INFO) {\n        m = this._logMe(`${this._getLogTime()}${this.OPEN_GROUP}INFO ${this.CLOSE_GROUP}${message}`, level);\n      }\n    }\n    return m;\n  };\n\n  /**\n   * Logs a message in info level\n   * @method info\n   * @param {string} message\n   * @memberof AbstractLogger\n   */\n  info(message) {\n    this.log(message, Level.INFO);\n  };\n\n  /**\n   * Log a message in error level\n   * @method error\n   * @param {string} message\n   * @memberof AbstractLogger\n   */\n  error(message) {\n    this.log(message, Level.ERROR);\n  };\n\n  /**\n   * Log a message in debug level\n   * @method debug\n   * @param {string} message\n   * @memberof AbstractLogger\n   */\n  debug(message) {\n    this.log(message, Level.DEBUG);\n  };\n\n  /**\n   * Log a message in warn level\n   * @method warn\n   * @param {string} message\n   * @memberof AbstractLogger\n   */\n  warn(message) {\n    this.log(message, Level.WARN);\n  };\n\n  /**\n   * logMe method - the actual logger method that logs.  Each instance will have it's own<br/>\n   * override this in an instance\n   * @example _logMe(message, level) { ... };\n   * @method _logMe\n   * @param {string} message The message to log\n   * @param {string} level The level to log to\n   * @returns {string} The message\n   * @memberof AbstractLogger\n   * @private\n   */\n   _logMe(message, level) {};\n};\n\nclass ConsoleLogger extends AbstractLogger {\n  constructor(l) {\n    super(l);\n  };\n  _logMe(message, level) {\n    if (level === Level.INFO) {\n      console.info(message);\n    } else if (level === Level.ERROR) {\n      console.error(message);\n    } else if (level === Level.DEBUG) {\n      console.log(message);\n    } else if (level === Level.WARN) {\n      console.warn(message);\n    } else {\n      console.log(message);\n    }\n    return message;\n  };\n};\n\nclass ColorConsoleLogger extends AbstractLogger {\n  constructor(l) {\n    super(l);\n  };\n  _logMe(message, level) {\n    if (level === Level.INFO) {\n      console.info(\"\\x1b[36m\" + message + \"\\x1b[0m\");\n    } else if (level === Level.ERROR) {\n      console.error(\"\\x1b[31m\" + message + \"\\x1b[0m\");\n    } else if (level === Level.DEBUG) {\n      console.log(\"\\x1b[34m\" + message + \"\\x1b[0m\");\n    } else if (level === Level.WARN) {\n      console.warn(\"\\x1b[33m\" + message + \"\\x1b[0m\");\n    } else {\n      console.log(\"\\x1b[37m\" + message + \"\\x1b[0m\");\n    }\n  };\n};\n\nclass RestLogger extends AbstractLogger {\n  constructor(l, uri) {\n    super(l);\n    this.uri = uri;\n  };\n  setURI(uri) {\n    this.uri = uri;\n  };\n  _logMe(message) {\n    // use new ajax promise\n    /*\n    Augmented.ajax({\n      url: this.uri,\n      method: \"POST\",\n      contentType: \"text/plain\",\n      dataType: \"text\",\n      async: true,\n      data: message,\n      success: function (data, status) { this.success(); },\n      failure: function (data, status) { this.failure(); }\n    });\n    */\n  };\n};\n\n/**\n* Augmented.Logger.LoggerFactory - A logger factory for creating a logger instance\n* @namespace Augmented.Logger.LoggerFactory\n* @memberof Augmented.Logger\n*/\nexport class LoggerFactory {\n  constructor() {\n  };\n  /**\n   * getLogger - get an instance of a logger\n   * @method getLogger\n   * @param {Augmented.Logger.Type} type Type of logger instance\n   * @param {Augmented.Logger.Level} level Level to set the logger to\n   * @memberof Augmented.Logger.LoggerFactory\n   * @returns {Augmented.Logger.abstractLogger} logger Instance of a logger by istance type\n   * @example Augmented.Logger.LoggerFactory.getLogger(Augmented.Logger.Type.console, Augmented.Logger.Level.debug);\n   */\n  static getLogger(type, level) {\n    if (type === Type.CONSOLE) {\n      return new ConsoleLogger(level);\n    } else if (type === Type.COLOR_CONSOLE) {\n      return new ColorConsoleLogger(level);\n    } else if (type === Type.REST) {\n      return new RestLogger(level);\n    }\n  };\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/logger.js","import isString from \"./isString.js\";\n\n/**\n * ES6-like Map - than can marshall\n * @constructor Augmented.Utility.Map\n * @param myData {object} Map data to fill map\n * @memberof Augmented.Utility\n */\nclass AugmentedMap {\n  constructor(myData) {\n    if (myData) {\n      this.marshall(myData);\n    }\n  };\n  _keys = [];\n  _data = {};\n\n  /**\n   * Set the value by key in the map\n   * @method set\n   * @memberof Augmented.Utility.Map\n   * @param {string} key name of the key\n   * @param {any} value value for the key\n   */\n  set(key, value) {\n    if (key !== null && value !== null) {\n      if (!this._data[key]) {\n        this._keys.push(key);\n      }\n      this._data[key] = value;\n    }\n  };\n\n  /**\n   * Get the value by key in the map\n   * @method get\n   * @memberof Augmented.Utility.Map\n   * @param {string} key name of the key\n   * @returns {any} The value for the key\n   */\n  get(key) {\n    return this._data[key];\n  };\n\n  /**\n   * Index of the key in the map\n   * @method indexOf\n   * @memberof Augmented.Utility.Map\n   * @param {string} key name of the key\n   * @returns {number} index of the key\n   */\n  indexOf(key) {\n    return this._keys.indexOf(key);\n  };\n\n  /**\n   * Remove the value by key in the map\n   * @method remove\n   * @memberof Augmented.Utility.Map\n   * @param {string} key name of the key\n   */\n  remove(key) {\n    const i = this.indexOf(key);\n    this._keys.splice(i, 1);\n    delete this._data[key];\n  };\n\n  /**\n   * Has returns whether a key exists in the map\n   * @method has\n   * @memberof Augmented.Utility.Map\n   * @param {string} key name of the key\n   * @returns {boolean} true if the key exists in the map\n   */\n  has(key) {\n    return (this.indexOf(key) !== -1);\n  };\n\n  /**\n   * Iterator forEach key to value in the map\n   * @method forEach\n   * @memberof Augmented.Utility.Map\n   * @param {function} fn callback for the iterator\n   */\n  forEach(fn) {\n    if (typeof fn !== \"function\") {\n      return null;\n    }\n    const len = this._keys.length;\n    let i = 0, k;\n    for (i = 0; i < len; i++) {\n      k = this._keys[i];\n      fn(k, this._data[k], i);\n    }\n  };\n\n  /**\n   * Get the key for the index in the map\n   * @method key\n   * @memberof Augmented.Utility.Map\n   * @param {number} i index of the key\n   * @returns {object} the key at index\n   */\n  key(i) {\n    return this._keys[i];\n  };\n\n  /**\n   * The entries value object in the map\n   * @method entries\n   * @memberof Augmented.Utility.Map\n   * @returns {array} Array of entries value objects\n   */\n  entries() {\n    let i = 0;\n    const len = this._keys.length, entries = new Array(len);\n    for (i = 0; i < len; i++) {\n      entries[i] = {\n        key : this._keys[i],\n        value : this._data[i]\n      };\n    }\n    return entries;\n  };\n\n  /**\n   * The values in the map as an Array\n   * @method values\n   * @memberof Augmented.Utility.Map\n   * @returns {array} values as an Array\n   */\n  values() {\n    const len = this._keys.length, values = new Array(len);\n    let i = 0, key;\n\n    for (i = 0; i < len; i++) {\n      key = this._keys[i];\n      values[i] = this._data[key];\n    }\n    return values;\n  };\n\n  /**\n   * Clear the map\n   * @method clear\n   * @memberof Augmented.Utility.Map\n   */\n  clear() {\n    this._keys = [];\n    this._data = {};\n  };\n\n  /**\n   * The size of the map in keys\n   * @method size\n   * @memberof Augmented.Utility.Map\n   * @returns {number} size of map by keys\n   */\n  size() {\n    return this._keys.length;\n  };\n\n  /**\n   * Represent the map in JSON\n   * @method toJSON\n   * @memberof Augmented.Utility.Map\n   * @returns {object} JSON of the map\n   */\n  toJSON() {\n    return this._data;\n  };\n\n  /**\n   * Represent the map in a String of JSON\n   * @method toString\n   * @memberof Augmented.Utility.Map\n   * @returns {string} Stringified JSON of the map\n   */\n  toString() {\n    return JSON.stringify(this._data);\n  };\n\n  // non-es6 API\n\n  /**\n   * Checks of the map is empty (not ES6)\n   * @method isEmpty\n   * @memberof Augmented.Utility.Map\n   * @returns {boolean} true if the map is empty\n   */\n  isEmpty() {\n    return this._keys.length === 0;\n  };\n\n  /**\n   * Marshalls a map<br/>\n   * dataToMarshall must be the following type of data to parse:\n   * JSON object with properties (key/value)\n   *\n   * @method marshall\n   * @param {Augmented.Utility.Map} dataToMarshall Data to marshall as a map\n   * @returns {boolean} Returns true on success\n   * @memberof Augmented.Utility.Map\n   */\n  marshall(dataToMarshall) {\n    let dataToParse;\n    if (dataToMarshall && dataToMarshall instanceof AugmentedMap) {\n      dataToParse = dataToMarshall.toJSON();\n    } else if(dataToMarshall && dataToMarshall instanceof Object && (Object.keys(dataToMarshall).length > 0)) {\n      dataToParse = dataToMarshall;\n    } else if(dataToMarshall && isString(dataToMarshall)) {\n      try {\n        dataToParse = JSON.parse(dataToMarshall);\n      } catch(e) {\n        //_logger.warn(\"AUGMENTED: Map: Could not marshall data: \" + JSON.stringify(dataToMarshall));\n        return false;\n      }\n    } else {\n      //_logger.warn(\"AUGMENTED: Map: Could not marshall data: \" + JSON.stringify(dataToMarshall));\n      return false;\n    }\n\n    const props = Object.keys(dataToParse),\n          l = props.length;\n    let i = 0;\n    for (i = 0; i < l; i++) {\n      const p = props[i],\n            v = dataToParse[p];\n      this.set(p, v);\n    }\n    return true;\n  };\n};\n\nexport default AugmentedMap;\n\n\n\n// WEBPACK FOOTER //\n// ./src/map.js","const _bind = require(\"lodash.bind\");\n\nlet idCounter = 0;\n\n// some lodash-like functions ported over\nconst _keys = (object) => {\n  return Object.keys(object);\n};\nconst _uniqueId = (prefix) => {\n  const id = ++idCounter;\n  return `{$prefix}${id}`;\n};\nconst _before = (nn, func) => {\n  let result, n;\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  n = Number.parseInt(nn);\n  return () => {\n    if (--n > 0) {\n      result = func.apply(this, arguments);\n    }\n    if (n <= 1) {\n      func = undefined;\n    }\n    return result;\n  };\n};\nconst _once = (func) => {\n  return _before(2, func);\n};\n\n\n// Events\n\n// Regular expression used to split event strings.\nconst EVENT_SPLITTER = /\\s+/;\n\n// Iterates over the standard `event, callback` (as well as the fancy multiple\n// space-separated events `\"change blur\", callback` and jQuery-style event\n// maps `{event: callback}`).\nconst eventsApi = (iteratee, events, name, callback, opts) => {\n  let i = 0, names;\n  if (name && typeof name === \"object\") {\n    // Handle event maps.\n    if (callback !== void 0 && \"context\" in opts && opts.context === void 0) {\n      opts.context = callback;\n    }\n    for (names = _keys(name); i < names.length; i++) {\n      events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\n    }\n  } else if (name && EVENT_SPLITTER.test(name)) {\n    // Handle space-separated event names by delegating them individually.\n    for (names = name.split(EVENT_SPLITTER); i < names.length; i++) {\n      events = iteratee(events, names[i], callback, opts);\n    }\n  } else {\n    // Finally, standard events.\n    events = iteratee(events, name, callback, opts);\n  }\n  return events;\n};\n\n// Guard the `listening` argument from the public API.\nconst internalOn = (obj, name, callback, context, listening) => {\n  obj._events = eventsApi(onApi, obj._events || {}, name, callback, {\n    context: context,\n    ctx: obj,\n    listening: listening\n  });\n\n  if (listening) {\n    const listeners = obj._listeners || (obj._listeners = {});\n    listeners[listening.id] = listening;\n  }\n  return obj;\n};\n\n// The reducing API that adds a callback to the `events` object.\nconst onApi = (events, name, callback, options) => {\n  if (callback) {\n    const handlers = events[name] || (events[name] = []);\n    const context = options.context, ctx = options.ctx, listening = options.listening;\n    if (listening) {\n      listening.count++;\n    }\n    handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });\n  }\n  return events;\n};\n\n// The reducing API that removes a callback from the `events` object.\nconst offApi = (events, name, callback, options) => {\n  if (!events) {\n    return;\n  }\n  let i = 0, listening;\n  const context = options.context, listeners = options.listeners;\n\n  // Delete all events listeners and \"drop\" events.\n  if (!name && !callback && !context) {\n    const ids = _keys(listeners);\n    for (; i < ids.length; i++) {\n      listening = listeners[ids[i]];\n      delete listeners[listening.id];\n      delete listening.listeningTo[listening.objId];\n    }\n    return;\n  }\n\n  let names = name ? [name] : _keys(events);\n  for (; i < names.length; i++) {\n    name = names[i];\n    const handlers = events[name];\n\n    // Bail out if there are no events stored.\n    if (!handlers) break;\n\n    // Replace events if there are any remaining.  Otherwise, clean up.\n    const remaining = [];\n    let j = 0;\n    for (j = 0; j < handlers.length; j++) {\n      const handler = handlers[j];\n      if (\n        callback && callback !== handler.callback &&\n          callback !== handler.callback._callback ||\n            context && context !== handler.context\n      ) {\n        remaining.push(handler);\n      } else {\n        listening = handler.listening;\n        if (listening && --listening.count === 0) {\n          delete listeners[listening.id];\n          delete listening.listeningTo[listening.objId];\n        }\n      }\n    }\n\n    // Update tail event if the list has any events.  Otherwise, clean up.\n    if (remaining.length) {\n      events[name] = remaining;\n    } else {\n      delete events[name];\n    }\n  }\n  return events;\n};\n\n// Handles triggering the appropriate event callbacks.\nconst triggerApi = (objEvents, name, callback, args) => {\n  if (objEvents) {\n    const events = objEvents[name];\n    let allEvents = objEvents.all;\n    if (events && allEvents) {\n      allEvents = allEvents.slice();\n    }\n    if (events) {\n      triggerEvents(events, args);\n    }\n    if (allEvents) {\n      triggerEvents(allEvents, [name].concat(args));\n    }\n  }\n  return objEvents;\n};\n\n// A difficult-to-believe, but optimized internal dispatch function for\n// triggering events. Tries to keep the usual cases speedy\nconst triggerEvents = (events, args) => {\n  let ev, i = -1;\n  const l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n  switch (args.length) {\n    case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n    case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n    case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n    case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n    default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;\n  }\n};\n\n/**\n * Augmented Object\n * Base class for other classes to extend from\n * @constructor Augmented.Object\n * @param {object} options Object options\n * @memberof Augmented\n */\nclass AugmentedObject {\n  constructor(options) {\n    if (!this.options) {\n      this._options = {};\n    }\n    if (options) {\n      Object.assign(this._options, options);\n    }\n  };\n  _options = {};\n  _events = {};\n  _listeningTo = {};\n  _listenId = {};\n  _listeners = {};\n\n  /**\n   * Initialize the object\n   * @method initialize\n   * @returns {object} Returns this context\n   * @memberof Augmented.Object\n   */\n  initialize(...args) {\n    return this;\n  };\n\n  get options() {\n    return this._options;\n  };\n\n  set options(options) {\n    this._options = options;\n  };\n\n  get events() {\n    return this._events;\n  };\n\n  /**\n   * Trigger one or many events, firing all bound callbacks. Callbacks are\n   * passed the same arguments as `trigger` is, apart from the event name\n   * (unless you're listening on `\"all\"`, which will cause your callback to\n   * receive the true name of the event as the first argument).\n   * @method trigger\n   * @param {string} name The name of the event\n   * @param {any} args any number of additional arguments\n   * @returns {object} Returns this context\n   * @memberof Augmented.Object\n   */\n  trigger(name, ...args) {\n    if (this._events) {\n      const length = Math.max(0, args.length - 1);\n      const argsA = Array(length);\n      let i = 0;\n      for (i = 0; i < length; i++) {\n        argsA[i] = args[i + 1];\n      }\n      eventsApi(triggerApi, this._events, name, void 0, argsA);\n    }\n    return this;\n  };\n\n  /**\n   * Bind an event to only be triggered a single time. After the first time\n   * the callback is invoked, its listener will be removed. If multiple events\n   * are passed in using the space-separated syntax, the handler will fire\n   * once for each event, not once for a combination of all events.\n   * @method once\n   * @param {string} name The name of the event\n   * @param {function} callback The callback to evoke\n   * @param {object} context The context of the callback\n   * @returns {object} Returns this context\n   * @memberof Augmented.Object\n   */\n  once(name, callback, context) {\n    // Map the event into a `{event: once}` object.\n    const events = eventsApi(this._onceMap, {}, name, callback, _bind(this.off, this));\n    if (typeof name === \"string\" && context == null) {\n      callback = void 0;\n    }\n    return this.on(events, callback, context);\n  };\n\n  /**\n   * Remove one or many callbacks. If `context` is null, removes all\n   * callbacks with that function. If `callback` is null, removes all\n   * callbacks for the event. If `name` is null, removes all bound\n   * callbacks for all events.\n   * @method off\n   * @param {string} name The name of the event\n   * @param {function} callback The callback to evoke\n   * @param {object} context The context of the callback\n   * @returns {object} Returns this context\n   * @memberof Augmented.Object\n   */\n  off(name, callback, context) {\n    if (this._events) {\n      this._events = eventsApi(offApi, this._events, name, callback, {\n        context: context,\n        listeners: this._listeners\n      });\n    }\n    return this;\n  };\n\n  /**\n   * Tell this object to stop listening to either specific events ... or\n   * to every object it's currently listening to.\n   * @method stopListening\n   * @param {object} obj The object to stop listening to\n   * @param {string} name The name of the event\n   * @param {function} callback The callback to evoke\n   * @returns {object} Returns this context\n   * @memberof Augmented.Object\n   */\n  stopListening(obj, name, callback) {\n    const listeningTo = this._listeningTo;\n    if (listeningTo) {\n      const ids = obj ? [obj._listenId] : _keys(listeningTo);\n      let i = 0;\n      for (i = 0; i < ids.length; i++) {\n        const listening = listeningTo[ids[i]];\n\n        // If listening doesn't exist, this object is not currently\n        // listening to obj. Break out early.\n        if (!listening) {\n          break;\n        }\n        listening.obj.off(name, callback, this);\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Bind an event to a `callback` function. Passing `\"all\"` will bind\n   * the callback to all events fired.\n   * @method on\n   * @param {string} name The name of the event\n   * @param {function} callback The callback to evoke\n   * @param {object} context The context of the callback\n   * @returns {object} Returns this context\n   * @memberof Augmented.Object\n   */\n  on(name, callback, context) {\n    return internalOn(this, name, callback, context);\n  };\n\n  /**\n   * Inversion-of-control versions of `on`. Tell *this* object to listen to\n   * an event in another object... keeping track of what it's listening to\n   * for easier unbinding later.\n   * @method listenTo\n   * @param {object} obj The object to stop listening to\n   * @param {string} name The name of the event\n   * @param {function} callback The callback to evoke\n   * @returns {object} Returns this context\n   * @memberof Augmented.Object\n   */\n  listenTo(obj, name, callback) {\n    if (obj) {\n      const id = obj._listenId || (obj._listenId = _uniqueId(\"l\"));\n      const listeningTo = this._listeningTo || (this._listeningTo = {});\n      let listening = listeningTo[id];\n\n      // This object is not listening to any other events on `obj` yet.\n      // Setup the necessary references to track the listening callbacks.\n      if (!listening) {\n        const thisId = this._listenId || (this._listenId = _uniqueId(\"l\"));\n        listening = listeningTo[id] = {obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0};\n      }\n\n      // Bind callbacks on obj, and keep track of them on listening.\n      internalOn(obj, name, callback, this, listening);\n    }\n    return this;\n  };\n\n  /**\n   * Inversion-of-control versions of `once`.\n   * @method listenToOnce\n   * @param {object} obj The object to stop listening to\n   * @param {string} name The name of the event\n   * @param {function} callback The callback to evoke\n   * @returns {object} Returns this context\n   * @memberof Augmented.Object\n   */\n  listenToOnce(obj, name, callback) {\n    // Map the event into a `{event: once}` object.\n    const events = eventsApi(this._onceMap, {}, name, callback, _bind(this.stopListening, this, obj));\n    return this.listenTo(obj, events);\n  };\n\n  // Reduces the event callbacks into a map of `{event: onceWrapper}`.\n  // `offer` unbinds the `onceWrapper` after it has been called.\n  _onceMap(map, name, callback, offer) {\n    if (callback) {\n      const __once = map[name] = _once(() => {\n        offer(name, __once);\n        callback.apply(this, arguments);\n      });\n      __once._callback = callback;\n    }\n    return map;\n  };\n};\n\nexport default AugmentedObject;\n\n\n\n// WEBPACK FOOTER //\n// ./src/object.js","/**\n* Augmented.Utility.Stack -\n* Standard Stack data structure\n* @constructor Augmented.Utility.Stack\n* @memberof Augmented.Utility\n*/\nclass Stack {\n  constructor() {\n  };\n\n  _stack = [];\n\n  /**\n  * The empty method clears the stack\n  * @method empty\n  * @memberof Augmented.Utility.Stack\n  */\n  empty() {\n    return (this._stack.length === 0);\n  };\n  /**\n  * The peek method returns the first in the stack\n  * @method peek\n  * @memberof Augmented.Utility.Stack\n  * @returns {object} Returns the first object in the stack\n  */\n  peek() {\n    return this._stack[0];\n  };\n  /**\n  * The pop method returns and removes the first in the stack\n  * @method pop\n  * @memberof Augmented.Utility.Stack\n  * @returns {object} Returns the first object in the stack\n  */\n  pop() {\n    return this._stack.pop();\n  };\n  /**\n  * The push method adds to the stack\n  * @method push\n  * @memberof Augmented.Utility.Stack\n  * @param {object} item The item to push to the stack\n  */\n  push(item) {\n    this._stack.push(item);\n  };\n  /**\n  * The search method returns where in the stack an item exists\n  * @method search\n  * @memberof Augmented.Utility.Stack\n  * @returns {number} Returns the index of the item\n  */\n  search(item) {\n    return this._stack.indexOf(item);\n  };\n  /**\n  * The size method returns the size of the stack\n  * @method size\n  * @memberof Augmented.Utility.Stack\n  * @returns {number} Returns the size of the stack\n  */\n  size() {\n    return this._stack.length;\n  };\n  /**\n  * The clear method clears the stack\n  * @method clear\n  * @memberof Augmented.Utility.Stack\n  */\n  clear() {\n    this._stack.splice(0, this._stack.length);\n  };\n  /**\n  * The toArray method returns the stack as an array\n  * @method toArray\n  * @memberof Augmented.Utility.Stack\n  * @returns {array} Returns the stack as an array\n  */\n  toArray() {\n    return this._stack;\n  };\n};\n\nexport default Stack;\n\n\n\n// WEBPACK FOOTER //\n// ./src/stack.js","/**\n * Utility Package -\n * Small Utilities\n * @namespace Augmented.Utility\n * @memberof Augmented\n */\n\n/**\n * Shuffles an Array with Fisher-Yates Shuffle algorithm\n * @constructor Augmented.Utility.Shuffle\n * @memberof Augmented.Utility\n * @param {array} array The array to shuffle\n * @returns {array} A new shuffled array\n */\nexport const shuffle = (array) => {\n  const nArray = array.slice(0), l = array.length;\n  let i = 0, temp, j;\n  for (i = l - 1; i > 0; i--) {\n    j = Math.floor(Math.random() * (i + 1));\n    temp = nArray[i];\n    nArray[i] = nArray[j];\n    nArray[j] = temp;\n  }\n  return nArray;\n};\n\n/**\n * Prints an object nicely\n * @constructor Augmented.Utility.PrettyPrint\n * @memberof Augmented.Utility\n * @param {object} obj The object to print\n * @param {boolean} spaces Use spaces instead of tabs\n * @returns {number} number The number of spaces to pad\n */\nexport const prettyPrint = (obj, spaces, number) => {\n  let x = \"\\t\";\n  if (spaces) {\n    x = \" \".repeat(number);\n  }\n  return JSON.stringify(obj, null, x);\n};\n\n/**\n * Sorts an array of objects by propery in object\n * @constructor Augmented.Utility.sortObjects\n * @memberof Augmented.Utility\n * @param {array} array The object array to sort\n * @param {object} key The property to sort by\n * @returns {array} The sorted array\n */\nexport const sortObjects = (array, key) => {\n  return array.sort( (a, b) => {\n    const x = a[key], y = b[key];\n    return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n  });\n};\n\n/**\n * Performs a binary search on the host array. vs indexOf<br/>\n * Binary Search is a complexity of <em>O(n log n)</em> vs <em>O(n)</em> with indexOf\n * @constructor Augmented.Utility.BinarySearch\n * @memberof Augmented.Utility\n * @param {Array} arr The array.\n * @param {Any} find The item to search for within the array.\n * @param {function} comparator The comparator to use\n * @returns {Number} The index of the element which defaults to -1 when not found.\n */\nexport const binarySearch = (arr, find, comparator) => {\n  let low = 0, high = arr.length - 1, i, comparison;\n\n  while (low <= high) {\n    i = Math.floor((low + high) / 2);\n    comparison = comparator(arr[i], find);\n    if (comparison < 0) {\n      low = i + 1; continue;\n    }\n    if (comparison > 0) {\n      high = i - 1; continue;\n    }\n    return i;\n  }\n  return null;\n};\n\n/**\n * Quick Sort implimentation for Arrays -\n * @constructor Augmented.Utility.QuickSort\n * @memberof Augmented.Utility\n * @param {Array} arr Array to Sort\n * @returns {Array} Returns a sorted array\n */\nexport const quickSort = (arr) => {\n  //if array is empty\n  if (arr.length === 0) {\n    return [];\n  }\n\n  let i = 1;\n  const l = arr.length, left = [], right = [], pivot = arr[0];\n  //go through each element in array\n  for (i = 1; i < l; i++) {\n    if (arr[i] < pivot) {\n      left.push(arr[i]);\n    } else {\n      right.push(arr[i]);\n    }\n  }\n  return quickSort(left).concat(pivot, quickSort(right));\n};\n\n/**\n * Augmented.Utility.TransformerType <br/>\n * Transformer type for use in the transformer\n * @enum {Symbol} Augmented.Utility.TransformerType\n * @name Augmented.Utility.TransformerType\n * @memberof Augmented.Utility\n * @property {Symbol} String Standard String\n * @property {Symbol} Integer Integer\n * @property {Symbol} Number Any number\n * @property {Symbol} Boolean True/False\n * @property {Symbol} Array Stanrdard Array\n * @property {Symbol} Object Any Object\n * @property {Symbol} Null Null\n */\nexport const TransformerType = {};\nTransformerType.STRING = Symbol(\"String\");\nTransformerType.INTEGER = Symbol(\"Integer\");\nTransformerType.NUMBER = Symbol(\"Number\");\nTransformerType.BOOLEAN = Symbol(\"Boolean\");\nTransformerType.ARRAY = Symbol(\"Array\");\nTransformerType.OBJECT = Symbol(\"Object\");\nTransformerType.NULL = Symbol(\"Null\");\n\n/**\n * Augmented.Utility.Transformer <br/>\n * Transform an object, type, or array to another type, object, or array\n * @namespace Augmented.Utility.Transformer\n * @memberof Augmented.Utility\n */\nexport class Transformer {\n  constructor() {\n  }\n\n  /**\n   * The transformer type enum\n   * @propery type The transformer type enum\n   * @type {Augmented.Utility.TransformerType}\n   * @memberof Augmented.Utility.Transformer\n   */\n  static type = TransformerType;\n\n  /**\n   * Transform an object, primitive, or array to another object, primitive, or array\n   * @method transform\n   * @param {object} source Source primitive to transform\n   * @param {Augmented.Utility.TransformerType} type Type to transform to\n   * @memberof Augmented.Utility.Transformer\n   * @returns {object} returns a transformed object or primitive\n   */\n  static transform(source, type) {\n    let out = null;\n    switch(type) {\n      case TransformerType.STRING:\n      if (typeof source === \"object\") {\n        out = JSON.stringify(source);\n      } else {\n        out = String(source);\n      }\n      break;\n      case TransformerType.INTEGER:\n      out = parseInt(source);\n      break;\n      case TransformerType.NUMBER:\n      out = Number(source);\n      break;\n      case TransformerType.BOOLEAN:\n      out = Boolean(source);\n      break;\n      case TransformerType.ARRAY:\n      if (!Array.isArray(source)) {\n        out = [];\n        out[0] = source;\n      } else {\n        out = source;\n      }\n      break;\n      case TransformerType.OBJECT:\n      if (typeof source !== \"object\") {\n        out = {};\n        out[source] = source;\n      } else {\n        out = source;\n      }\n      break;\n    }\n    return out;\n  };\n\n  /**\n   * Returns a Augmented.Utility.TransformerType of a passed object\n   * @method isType\n   * @memberof Augmented.Utility.Transformer\n   * @param {object} source The source primitive\n   * @returns {Augmented.Utility.TransformerType} type of source as Augmented.Utility.TransformerType\n   */\n  static isType(source) {\n    if (source === null) {\n      return TransformerType.NULL;\n    } else if (typeof source === \"string\") {\n      return TransformerType.STRING;\n    } else if (typeof source === \"number\") {\n      return TransformerType.NUMBER;\n    } else if (typeof source === \"boolean\") {\n      return TransformerType.BOOLEAN;\n    } else if (Array.isArray(source)) {\n      return TransformerType.ARRAY;\n    } else if (typeof source === \"object\") {\n      return TransformerType.OBJECT;\n    }\n  }\n};\n\n/**\n * Wrap method to handle wrapping functions (simular to _.wrap)\n * @method wrap\n * @memberof Augmented.Utility\n */\nexport const wrap = (fn, wrap) => {\n  return () => {\n    return wrap.apply(this, [fn].concat(Array.prototype.slice.call(arguments)));\n  };\n};\n\n/**\n * filter an oject from array of values\n *\n * @method filterObject\n * @param {object} object Object to filter\n * @param {array} keys keys to filter from the object\n * @returns {object} returns a new object with only these keys\n * @memberof Augmented.Utility\n */\nexport const filterObject = (object, keys) => {\n  const newObject = {};\n  if (object && keys) {\n    const l = keys.length;\n    let i = 0;\n    for (i = 0; i < l; i++) {\n      newObject[keys[i]] = object[keys[i]];\n    }\n  }\n  return newObject;\n};\n\nexport const extend = (...args) => {\n  let i = 0;\n  const l = args.length;\n  for (i = 1; i < l; i++) {\n    let key;\n    for(key in args[i]) {\n      if(args[i].hasOwnProperty(key)) {\n        args[0][key] = args[i][key];\n      }\n    }\n  }\n  return args[0];\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/utility.js","import * as Utility from \"./utility\";\nimport * as Logger from \"./logger\";\nimport AugmentedObject from \"./object.js\";\nimport AugmentedMap from \"./map.js\";\nimport isString from \"./isString.js\";\nimport Stack from \"./stack.js\";\n\n/**\n * Augmented.js 2 - The Core UI Component and package\n *\n * @author Bob Warren\n *\n * @module Augmented\n * @version 2.0.0\n * @license Apache-2.0\n */\nconst Augmented = {};\nAugmented.Utility = Utility;\nAugmented.Utility.Map = AugmentedMap;\nAugmented.Utility.Stack = Stack;\nAugmented.Logger = Logger;\nAugmented.Object = AugmentedObject;\n\n/**\n * The standard version property\n * @constant VERSION\n */\nAugmented.VERSION = \"2.0.0\";\n/**\n * A codename for internal use\n * @constant codename\n */\nAugmented.codename = \"JC Denton\";\n/**\n * A release name to help with identification of minor releases\n * @constant releasename\n */\nAugmented.releasename = \"UNATCO\";\n\n/**\n * Augmented underscore (if it exists from Backbone.js)\n * @module _\n * @name _\n * @memberof Augmented\n */\nAugmented._ = {};\n\n/**\n * Augmented underscore (if it exists from Backbone.js)\n * @module $\n * @name $\n * @memberof Augmented\n */\nAugmented.$ = {};\n\n/**\n * Augmented.Configuration - a set of configuration properties for the framework\n * @enum Configuration\n * @memberof Augmented\n * @property {string} LoggerLevel The level of the framework internal logger\n * @property {string} MessageBundle - the base name for messages in the framework (default: Messages)\n * @property {number} AsynchronousQueueTimeout the default milisecond timeout (default: 2000)\n * @property {number} ApplicationInitProcessTimeout the application init even timeout (default: 1000)\n * @todo change logger level to error\n */\nAugmented.Configuration = {\n  LoggerLevel: \"info\",\n  MessageBundle: \"Messages\",\n  AsynchronousQueueTimeout: 2000,\n  ApplicationInitProcessTimeout: 1000\n};\n\n/*\n * Base functionality\n * Set of base capabilities used throughout the framework\n */\n\n/**\n * Augmented.has\n * @method has\n * @memberof Augmented\n * @param {object} obj The input object\n * @param {object} key The test key\n * @returns {boolean} Returns true of the key exists\n */\nAugmented.has = (obj, key) => {\n  return obj !== null && hasOwnProperty.call(obj, key);\n};\n\n/**\n * Augmented.isObject\n * @method isObject\n * @memberof Augmented\n * @param {object} obj The input object\n * @returns {boolean} Returns true of the param is an object\n */\nAugmented.isObject = (obj) => {\n  const type = typeof obj;\n  return (type === \"function\" || type === \"object\" && !!obj);\n};\n\n/**\n * Augmented.allKeys\n * @method allKeys\n * @memberof Augmented\n * @param {object} obj The input object\n * @returns {array} Returns the array of ALL keys including prototyped\n */\nAugmented.allKeys = (obj) => {\n  if (!Augmented.isObject(obj)) return [];\n  return Object.getOwnPropertyNames(obj);\n};\n\n\nconst result = (prototype) => {\n  if (!Augmented.isObject(prototype)) {\n    return {};\n  }\n  return Object.create(prototype);\n};\n\n/**\n * Augmented.create\n * @method create\n * @memberof Augmented\n * @param {object} prototype The input prototype\n * @param {object} props The properties (optional)\n * @returns {object} Returns the created object\n */\nAugmented.create = (prototype, props) => {\n  const o = result(prototype);\n  if (props) {\n    Object.assign(o, props);\n  }\n  return o;\n};\n\n// Map from CRUD to HTTP for our default sync implementation.\nconst methodMap = {\n  \"create\": \"POST\",\n  \"update\": \"PUT\",\n  \"patch\": \"PATCH\",\n  \"delete\": \"DELETE\",\n  \"read\": \"GET\"\n};\n\n/**\n * Augmented.sync - Base sync method that can pass special augmented features\n * @method sync\n * @memberof Augmented\n */\nAugmented.sync = (method, model, options) => {\n  const type = methodMap[method];\n\n  if (!options) {\n    options = {};\n  }\n\n  // Default JSON-request options.\n  const params = {type: type, dataType: \"json\"};\n\n  // Ensure that we have a URL.\n  if (!options.url) {\n    if (model.url) {\n      if (Augmented.isFunction(model.url)) {\n        params.url = model.url();\n      } else {\n        params.url = model.url;\n      }\n    } else {\n      throw new Error(\"A \\\"url\\\" property or function must be specified\");\n    }\n  }\n\n  // Ensure that we have the appropriate request data.\n  if (options.data == null && model && (method === \"create\" || method === \"update\" || method === \"patch\")) {\n    params.contentType = \"application/json\";\n    params.data = JSON.stringify(options.attrs || model.toJSON(options));\n  }\n\n  // Don't process data on a non-GET request.\n  if (params.type !== \"GET\") {\n    params.processData = false;\n  }\n\n  // Pass along `textStatus` and `errorThrown` from jQuery.\n  const error = options.error;\n  options.error = (xhr, textStatus, errorThrown) => {\n    options.textStatus = textStatus;\n    options.errorThrown = errorThrown;\n    if (error) {\n      error.call(options.context, xhr, textStatus, errorThrown);\n    }\n  };\n\n  // Make the request, allowing the user to override any Ajax options.\n  const xhr = options.xhr = Augmented.ajax(Augmented.Utility.extend(params, options));\n  model.trigger(\"request\", model, xhr, options);\n  return xhr;\n};\n\n/**\n* Augmented.isFunction -\n* returns true if called name is a function\n* simular to jQuery .isFunction method\n* @method Augmented.isFunction\n* @param {function} name The name of the function to test\n* @memberof Augmented\n* @returns true if called name is a function\n*/\nAugmented.isFunction = (name) => {\n  return Object.prototype.toString.call(name) == \"[object Function]\";\n};\n\n// imported\nAugmented.isString = isString;\n\n/**\n* Augmented.result - returns named property in an object\n* simular to underscore .result method\n* @function result\n* @memberof Augmented\n* @returns named property in an object\n*/\nAugmented.result = (object, property) => {\n  if (object === null) return;\n  const value = object[property];\n  return Augmented.isFunction(value) ? value.call(object) : value;\n};\n\n/**\n * Array.has - returns is a property is in the array (very fast return)\n * @function arrayhas\n * @memberof Augmented\n * @param {array} arr Source array\n * @param {object} key Key to test for\n * @returns true if property is included in an array\n */\nAugmented.arrayHas = (arr, key) => {\n  return (arr.indexOf(key) !== -1);\n};\n\n/**\n * exec method - Execute a function by name\n * @method exec\n * @memberof Augmented\n * @param {string} functionName The name of the function\n * @param {object} context The context to call from\n * @param (object) args Arguments\n */\nAugmented.exec = (functionName, context /*, args */) => {\n  const args = Array.prototype.slice.call(arguments, 2),\n        namespaces = functionName.split(\".\"),\n        func = namespaces.pop(),\n        l = namespaces.length;\n  let i = 0;\n  for (i = 0; i < l; i++) {\n    context = context[namespaces[i]];\n  }\n  return context[func].apply(context, args);\n};\n\n/**\n * Augmented.isDefined - Checks and returns if a passed variable is defined\n * @method isDefined\n * @memberof Augmented\n * @param {string} variable to check\n * @returns {boolean} true if value is defined\n */\nAugmented.isDefined = (val) => {\n  return typeof val != \"undefined\";\n};\n\nexport default Augmented;\n\n//module.exports = Augmented;\n\n\n\n// WEBPACK FOOTER //\n// ./src/augmented.js","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as the internal argument placeholder. */\nvar PLACEHOLDER = '__lodash_placeholder__';\n\n/** Used to compose bitmasks for function metadata. */\nvar BIND_FLAG = 1,\n    BIND_KEY_FLAG = 2,\n    CURRY_BOUND_FLAG = 4,\n    CURRY_FLAG = 8,\n    CURRY_RIGHT_FLAG = 16,\n    PARTIAL_FLAG = 32,\n    PARTIAL_RIGHT_FLAG = 64,\n    ARY_FLAG = 128,\n    REARG_FLAG = 256,\n    FLIP_FLAG = 512;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991,\n    MAX_INTEGER = 1.7976931348623157e+308,\n    NAN = 0 / 0;\n\n/** Used to associate wrap methods with their bit flags. */\nvar wrapFlags = [\n  ['ary', ARY_FLAG],\n  ['bind', BIND_FLAG],\n  ['bindKey', BIND_KEY_FLAG],\n  ['curry', CURRY_FLAG],\n  ['curryRight', CURRY_RIGHT_FLAG],\n  ['flip', FLIP_FLAG],\n  ['partial', PARTIAL_FLAG],\n  ['partialRight', PARTIAL_RIGHT_FLAG],\n  ['rearg', REARG_FLAG]\n];\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to match wrap detail comments. */\nvar reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n    reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n    reSplitDetails = /,? & /;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array ? array.length : 0;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  if (value !== value) {\n    return baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * Gets the number of `placeholder` occurrences in `array`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} placeholder The placeholder to search for.\n * @returns {number} Returns the placeholder count.\n */\nfunction countHolders(array, placeholder) {\n  var length = array.length,\n      result = 0;\n\n  while (length--) {\n    if (array[length] === placeholder) {\n      result++;\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Replaces all `placeholder` elements in `array` with an internal placeholder\n * and returns an array of their indexes.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {*} placeholder The placeholder to replace.\n * @returns {Array} Returns the new array of placeholder indexes.\n */\nfunction replaceHolders(array, placeholder) {\n  var index = -1,\n      length = array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (value === placeholder || value === PLACEHOLDER) {\n      array[index] = PLACEHOLDER;\n      result[resIndex++] = index;\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/* Used to set `toString` methods. */\nvar defineProperty = (function() {\n  var func = getNative(Object, 'defineProperty'),\n      name = getNative.name;\n\n  return (name && name.length > 2) ? func : undefined;\n}());\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = array;\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Creates an array that is the composition of partially applied arguments,\n * placeholders, and provided arguments into a single array of arguments.\n *\n * @private\n * @param {Array} args The provided arguments.\n * @param {Array} partials The arguments to prepend to those provided.\n * @param {Array} holders The `partials` placeholder indexes.\n * @params {boolean} [isCurried] Specify composing for a curried function.\n * @returns {Array} Returns the new array of composed arguments.\n */\nfunction composeArgs(args, partials, holders, isCurried) {\n  var argsIndex = -1,\n      argsLength = args.length,\n      holdersLength = holders.length,\n      leftIndex = -1,\n      leftLength = partials.length,\n      rangeLength = nativeMax(argsLength - holdersLength, 0),\n      result = Array(leftLength + rangeLength),\n      isUncurried = !isCurried;\n\n  while (++leftIndex < leftLength) {\n    result[leftIndex] = partials[leftIndex];\n  }\n  while (++argsIndex < holdersLength) {\n    if (isUncurried || argsIndex < argsLength) {\n      result[holders[argsIndex]] = args[argsIndex];\n    }\n  }\n  while (rangeLength--) {\n    result[leftIndex++] = args[argsIndex++];\n  }\n  return result;\n}\n\n/**\n * This function is like `composeArgs` except that the arguments composition\n * is tailored for `_.partialRight`.\n *\n * @private\n * @param {Array} args The provided arguments.\n * @param {Array} partials The arguments to append to those provided.\n * @param {Array} holders The `partials` placeholder indexes.\n * @params {boolean} [isCurried] Specify composing for a curried function.\n * @returns {Array} Returns the new array of composed arguments.\n */\nfunction composeArgsRight(args, partials, holders, isCurried) {\n  var argsIndex = -1,\n      argsLength = args.length,\n      holdersIndex = -1,\n      holdersLength = holders.length,\n      rightIndex = -1,\n      rightLength = partials.length,\n      rangeLength = nativeMax(argsLength - holdersLength, 0),\n      result = Array(rangeLength + rightLength),\n      isUncurried = !isCurried;\n\n  while (++argsIndex < rangeLength) {\n    result[argsIndex] = args[argsIndex];\n  }\n  var offset = argsIndex;\n  while (++rightIndex < rightLength) {\n    result[offset + rightIndex] = partials[rightIndex];\n  }\n  while (++holdersIndex < holdersLength) {\n    if (isUncurried || argsIndex < argsLength) {\n      result[offset + holders[holdersIndex]] = args[argsIndex++];\n    }\n  }\n  return result;\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Creates a function that wraps `func` to invoke it with the optional `this`\n * binding of `thisArg`.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createBind(func, bitmask, thisArg) {\n  var isBind = bitmask & BIND_FLAG,\n      Ctor = createCtor(func);\n\n  function wrapper() {\n    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n    return fn.apply(isBind ? thisArg : this, arguments);\n  }\n  return wrapper;\n}\n\n/**\n * Creates a function that produces an instance of `Ctor` regardless of\n * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n *\n * @private\n * @param {Function} Ctor The constructor to wrap.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createCtor(Ctor) {\n  return function() {\n    // Use a `switch` statement to work with class constructors. See\n    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n    // for more details.\n    var args = arguments;\n    switch (args.length) {\n      case 0: return new Ctor;\n      case 1: return new Ctor(args[0]);\n      case 2: return new Ctor(args[0], args[1]);\n      case 3: return new Ctor(args[0], args[1], args[2]);\n      case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n    }\n    var thisBinding = baseCreate(Ctor.prototype),\n        result = Ctor.apply(thisBinding, args);\n\n    // Mimic the constructor's `return` behavior.\n    // See https://es5.github.io/#x13.2.2 for more details.\n    return isObject(result) ? result : thisBinding;\n  };\n}\n\n/**\n * Creates a function that wraps `func` to enable currying.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n * @param {number} arity The arity of `func`.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createCurry(func, bitmask, arity) {\n  var Ctor = createCtor(func);\n\n  function wrapper() {\n    var length = arguments.length,\n        args = Array(length),\n        index = length,\n        placeholder = getHolder(wrapper);\n\n    while (index--) {\n      args[index] = arguments[index];\n    }\n    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n      ? []\n      : replaceHolders(args, placeholder);\n\n    length -= holders.length;\n    if (length < arity) {\n      return createRecurry(\n        func, bitmask, createHybrid, wrapper.placeholder, undefined,\n        args, holders, undefined, undefined, arity - length);\n    }\n    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n    return apply(fn, this, args);\n  }\n  return wrapper;\n}\n\n/**\n * Creates a function that wraps `func` to invoke it with optional `this`\n * binding of `thisArg`, partial application, and currying.\n *\n * @private\n * @param {Function|string} func The function or method name to wrap.\n * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {Array} [partials] The arguments to prepend to those provided to\n *  the new function.\n * @param {Array} [holders] The `partials` placeholder indexes.\n * @param {Array} [partialsRight] The arguments to append to those provided\n *  to the new function.\n * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n * @param {Array} [argPos] The argument positions of the new function.\n * @param {number} [ary] The arity cap of `func`.\n * @param {number} [arity] The arity of `func`.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n  var isAry = bitmask & ARY_FLAG,\n      isBind = bitmask & BIND_FLAG,\n      isBindKey = bitmask & BIND_KEY_FLAG,\n      isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),\n      isFlip = bitmask & FLIP_FLAG,\n      Ctor = isBindKey ? undefined : createCtor(func);\n\n  function wrapper() {\n    var length = arguments.length,\n        args = Array(length),\n        index = length;\n\n    while (index--) {\n      args[index] = arguments[index];\n    }\n    if (isCurried) {\n      var placeholder = getHolder(wrapper),\n          holdersCount = countHolders(args, placeholder);\n    }\n    if (partials) {\n      args = composeArgs(args, partials, holders, isCurried);\n    }\n    if (partialsRight) {\n      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n    }\n    length -= holdersCount;\n    if (isCurried && length < arity) {\n      var newHolders = replaceHolders(args, placeholder);\n      return createRecurry(\n        func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n        args, newHolders, argPos, ary, arity - length\n      );\n    }\n    var thisBinding = isBind ? thisArg : this,\n        fn = isBindKey ? thisBinding[func] : func;\n\n    length = args.length;\n    if (argPos) {\n      args = reorder(args, argPos);\n    } else if (isFlip && length > 1) {\n      args.reverse();\n    }\n    if (isAry && ary < length) {\n      args.length = ary;\n    }\n    if (this && this !== root && this instanceof wrapper) {\n      fn = Ctor || createCtor(fn);\n    }\n    return fn.apply(thisBinding, args);\n  }\n  return wrapper;\n}\n\n/**\n * Creates a function that wraps `func` to invoke it with the `this` binding\n * of `thisArg` and `partials` prepended to the arguments it receives.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} partials The arguments to prepend to those provided to\n *  the new function.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createPartial(func, bitmask, thisArg, partials) {\n  var isBind = bitmask & BIND_FLAG,\n      Ctor = createCtor(func);\n\n  function wrapper() {\n    var argsIndex = -1,\n        argsLength = arguments.length,\n        leftIndex = -1,\n        leftLength = partials.length,\n        args = Array(leftLength + argsLength),\n        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n    while (++leftIndex < leftLength) {\n      args[leftIndex] = partials[leftIndex];\n    }\n    while (argsLength--) {\n      args[leftIndex++] = arguments[++argsIndex];\n    }\n    return apply(fn, isBind ? thisArg : this, args);\n  }\n  return wrapper;\n}\n\n/**\n * Creates a function that wraps `func` to continue currying.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n * @param {Function} wrapFunc The function to create the `func` wrapper.\n * @param {*} placeholder The placeholder value.\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {Array} [partials] The arguments to prepend to those provided to\n *  the new function.\n * @param {Array} [holders] The `partials` placeholder indexes.\n * @param {Array} [argPos] The argument positions of the new function.\n * @param {number} [ary] The arity cap of `func`.\n * @param {number} [arity] The arity of `func`.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n  var isCurry = bitmask & CURRY_FLAG,\n      newHolders = isCurry ? holders : undefined,\n      newHoldersRight = isCurry ? undefined : holders,\n      newPartials = isCurry ? partials : undefined,\n      newPartialsRight = isCurry ? undefined : partials;\n\n  bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\n  bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\n\n  if (!(bitmask & CURRY_BOUND_FLAG)) {\n    bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n  }\n\n  var result = wrapFunc(func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity);\n  result.placeholder = placeholder;\n  return setWrapToString(result, func, bitmask);\n}\n\n/**\n * Creates a function that either curries or invokes `func` with optional\n * `this` binding and partially applied arguments.\n *\n * @private\n * @param {Function|string} func The function or method name to wrap.\n * @param {number} bitmask The bitmask flags.\n *  The bitmask may be composed of the following flags:\n *     1 - `_.bind`\n *     2 - `_.bindKey`\n *     4 - `_.curry` or `_.curryRight` of a bound function\n *     8 - `_.curry`\n *    16 - `_.curryRight`\n *    32 - `_.partial`\n *    64 - `_.partialRight`\n *   128 - `_.rearg`\n *   256 - `_.ary`\n *   512 - `_.flip`\n * @param {*} [thisArg] The `this` binding of `func`.\n * @param {Array} [partials] The arguments to be partially applied.\n * @param {Array} [holders] The `partials` placeholder indexes.\n * @param {Array} [argPos] The argument positions of the new function.\n * @param {number} [ary] The arity cap of `func`.\n * @param {number} [arity] The arity of `func`.\n * @returns {Function} Returns the new wrapped function.\n */\nfunction createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n  var isBindKey = bitmask & BIND_KEY_FLAG;\n  if (!isBindKey && typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var length = partials ? partials.length : 0;\n  if (!length) {\n    bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\n    partials = holders = undefined;\n  }\n  ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n  arity = arity === undefined ? arity : toInteger(arity);\n  length -= holders ? holders.length : 0;\n\n  if (bitmask & PARTIAL_RIGHT_FLAG) {\n    var partialsRight = partials,\n        holdersRight = holders;\n\n    partials = holders = undefined;\n  }\n\n  var newData = [\n    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n    argPos, ary, arity\n  ];\n\n  func = newData[0];\n  bitmask = newData[1];\n  thisArg = newData[2];\n  partials = newData[3];\n  holders = newData[4];\n  arity = newData[9] = newData[9] == null\n    ? (isBindKey ? 0 : func.length)\n    : nativeMax(newData[9] - length, 0);\n\n  if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {\n    bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);\n  }\n  if (!bitmask || bitmask == BIND_FLAG) {\n    var result = createBind(func, bitmask, thisArg);\n  } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {\n    result = createCurry(func, bitmask, arity);\n  } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {\n    result = createPartial(func, bitmask, thisArg, partials);\n  } else {\n    result = createHybrid.apply(undefined, newData);\n  }\n  return setWrapToString(result, func, bitmask);\n}\n\n/**\n * Gets the argument placeholder value for `func`.\n *\n * @private\n * @param {Function} func The function to inspect.\n * @returns {*} Returns the placeholder value.\n */\nfunction getHolder(func) {\n  var object = func;\n  return object.placeholder;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Extracts wrapper details from the `source` body comment.\n *\n * @private\n * @param {string} source The source to inspect.\n * @returns {Array} Returns the wrapper details.\n */\nfunction getWrapDetails(source) {\n  var match = source.match(reWrapDetails);\n  return match ? match[1].split(reSplitDetails) : [];\n}\n\n/**\n * Inserts wrapper `details` in a comment at the top of the `source` body.\n *\n * @private\n * @param {string} source The source to modify.\n * @returns {Array} details The details to insert.\n * @returns {string} Returns the modified source.\n */\nfunction insertWrapDetails(source, details) {\n  var length = details.length,\n      lastIndex = length - 1;\n\n  details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n  details = details.join(length > 2 ? ', ' : ' ');\n  return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Reorder `array` according to the specified indexes where the element at\n * the first index is assigned as the first element, the element at\n * the second index is assigned as the second element, and so on.\n *\n * @private\n * @param {Array} array The array to reorder.\n * @param {Array} indexes The arranged array indexes.\n * @returns {Array} Returns `array`.\n */\nfunction reorder(array, indexes) {\n  var arrLength = array.length,\n      length = nativeMin(indexes.length, arrLength),\n      oldArray = copyArray(array);\n\n  while (length--) {\n    var index = indexes[length];\n    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n  }\n  return array;\n}\n\n/**\n * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n * with wrapper details in a comment at the top of the source body.\n *\n * @private\n * @param {Function} wrapper The function to modify.\n * @param {Function} reference The reference function.\n * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n * @returns {Function} Returns `wrapper`.\n */\nvar setWrapToString = !defineProperty ? identity : function(wrapper, reference, bitmask) {\n  var source = (reference + '');\n  return defineProperty(wrapper, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)))\n  });\n};\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Updates wrapper `details` based on `bitmask` flags.\n *\n * @private\n * @returns {Array} details The details to modify.\n * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n * @returns {Array} Returns `details`.\n */\nfunction updateWrapDetails(details, bitmask) {\n  arrayEach(wrapFlags, function(pair) {\n    var value = '_.' + pair[0];\n    if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n      details.push(value);\n    }\n  });\n  return details.sort();\n}\n\n/**\n * Creates a function that invokes `func` with the `this` binding of `thisArg`\n * and `partials` prepended to the arguments it receives.\n *\n * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n * may be used as a placeholder for partially applied arguments.\n *\n * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n * property of bound functions.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to bind.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {...*} [partials] The arguments to be partially applied.\n * @returns {Function} Returns the new bound function.\n * @example\n *\n * function greet(greeting, punctuation) {\n *   return greeting + ' ' + this.user + punctuation;\n * }\n *\n * var object = { 'user': 'fred' };\n *\n * var bound = _.bind(greet, object, 'hi');\n * bound('!');\n * // => 'hi fred!'\n *\n * // Bound with placeholders.\n * var bound = _.bind(greet, object, _, '!');\n * bound('hi');\n * // => 'hi fred!'\n */\nvar bind = baseRest(function(func, thisArg, partials) {\n  var bitmask = BIND_FLAG;\n  if (partials.length) {\n    var holders = replaceHolders(partials, getHolder(bind));\n    bitmask |= PARTIAL_FLAG;\n  }\n  return createWrap(func, bitmask, thisArg, partials, holders);\n});\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n// Assign default placeholders.\nbind.placeholder = {};\n\nmodule.exports = bind;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash.bind/index.js\n// module id = 7\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 8\n// module chunks = 0"],"sourceRoot":""}